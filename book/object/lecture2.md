# 객체지향 프로그래밍
## 영화 예매 시스템

### 요구사항 살펴보기
- 할인액을 결정하는 할인 조건<sup>discount condition</sup> 과 할인 정책<sup>discount policy</sup>이 존재

## 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스
- 진정한 객체지향 패러다임으로의 전환은 아래 두가지에 집중해야 함.
	- 어떤 클래스가 필요한지를 고민하기 전에 어떤 `객체`가 필요한지 고민할 것.
	- 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 `협력`하는 공동체의 일원으로 볼 것.

### 도메인의 구조를 따르르는 프로그램 구조
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 `도메인`이라고 부름.

### 클래스 구현하기

#### 자율적인 객체
- 객체가 상태와 행동을 함께 가지는 `복합적인` 존재.
- 객체가 스스로 판단하고 행동하는 `자율적인` 존재.

#### 프로그래머의 자유
- 클라이언트 개발자가 숨겨놓은 부분에 접근하지 못하도록 방지함으로써 내부구현을 마음대로 변경할 수 있는데 이것을 `정보은닉`이라고 부른다.

#### 협력에 관한 짧은 이야기
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 `메시지를 전송` 하는 것.
- 다른 객체에게 요청이 도착할 때 해당 객체가 `메시지를 수신`했다고 함.
- 수신된 메시지를 처리하기 위한 객체 자신만의 방법을 `메서드`라고 함.

### 할인 정책과 할인 조건
- 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴<sup>TEMPLATE PATTERN</sup>
![discount_policy.JPG](discount_policy.JPG)

### 할인 정책 구성하기
```java
Movie titanic = new Movie("타이타닉",
	Duration.ofMinutes(180),
	Money.wons(11000),
	new PercentDiscountPolicy(0.1),
		new PeriodCondition(DayOfWeek.TUESDAY, LocalTime.of(14,0), LocalTime.of(16, 59),
		new SequenceCondition(2),
		new PeriodCondition(DayOfWeek.THURSDAY, LocalTime.of(10,0), LocalTime.of(13, 59)));
```

## 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성
- 코드의 의존성과 실행 시점의 의존성이 다를 수 있음.
- 다르면 다를 수록, 코드의 가독성이 떨어지지만, 유연하해지고 확장 가능해짐.(의존성의 양면성은 설계가 트레이드오프의 산물이라는 것을 잘 보여줌.)

### 상속과 인터페이스
- 대부분의 사람들은 상속의 목적이 메서드나 인스턴스 변수를 재사용하는 것이라고 생각함. 그러나 이것은 잘못된 것임. 나중에 설명
- 자식 클래스가 부모 클래스를 대신하는 것을 `업캐스팅`<sup>upcasting</sup>이라고 부름. 아래에 위치한 자식 클래스가 위에 위치한 부모클래스로 타입 캐스팅 되는 것 처럼 보이기 때문
![upcasting.JPG](upcasting.JPG)

### 다형성
- 동일한 메시지를 전송하지만 실제 어떤 메서드가 실행될 것인지는 메시지를 수신하는 클래슥사 무엇이냐에 따라 달라지는데 이것이 `다형성`.
- 다형성을 구현하는 방법은 여러가지지만, 실행사긴에 결정한다는 공통점이 있음. 이것은 `지연 바인딩` 또는 `동적 바인딩` 이라고 함.


### 구현 상속과 인터페이스 상속
- 구현상속을 서브클래싱<sup>subclassing</sup>
- 인터페이스 상속을 서브타이핑<sup>subtyping</sup>
- 인터페이스를 재사용할 목적이 아니라 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높음.

### 인터페이스와 다형성
![discount_condition_interface.JPG](discount_condition_interface.JPG)


## 추상화와 유연성
- 추상화를 사용할 경우 첫째, 요구사항의 정책을 높은 수준에서 서술 가능.
- 둘째, 설계가 좀 더 유연해짐.

### 유연한 설계
- 스타워즈 할인 정책(정책이 없이 무조건 0원을 받는 ..)
![using_abstract.JPG](using_abstract.JPG)

![using_interface.JPG](using_interface.JPG)

### 코드 재사용
- 코드의 재사용을 위해서는 상속보다 `합성`<sup>composition</sup>이 더 좋다.
- 합성은 다른 객체의 인서턴스를 자신의 인스턴스 변수로 포함하여 재사용하는 것을 의미.

### 상속
- 상속은 `캡슐화`를 위반하고 `설계를 유연하게 하지` 못함.
- 부모 클래스를 잘 알아야 하므로 캡슐화를 위반.
- 부모 클래스와 자식 클래스를 컴파일 시점에 결정하므로 실행시점에 객체의 종류를 정하지 못해서 유연하지 않음.

### 합성
- Movie와 DiscountPolicy의 인터페이스를 통해 약하게 결합되어있고 DiscountPolicy가 calculateDiscountAmount 메서드를 제공한다는 사실만 알고 내부 구현을 모름.(캡슐화)
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법이 합성인데, 느슨하게 결합하므로 합성을 선호하는 것이 더 좋은 방법.

#### 정리하면
- 상속을 절대 사용하지 말라는 것은 아님. DiscountPolicy와 AmountDiscountPolicy, PercentDiscountPolicy 는 상속으로 연결되어있다. 
- 객체지향 설계의 핵심은 `적절한 협력`을 **식별**하고 `협력에 필요한 역할`을 **정의**하여, `적절한 객체`에 **책임**을 할당하는 것.

