# 목차

- [1장 HTTP 개관]()
- [2장 URL과 리소스]()
- [3장 HTTP 메시지]()
- [4장 커넥션 관리]()

---

2장 URL과 리소스
2.1 인터넷의 리소스 탐색하기 
2.2 URL 문법
2.3 단축 URL
2.4 안전하지 않은 문자
2.5 스킴의 바다 
2.6 미래 
2.7 추가 정보

3장 HTTP 메시지 
3.1 메시지의 흐름 
3.2 메시지의 각 부분 
3.3 메서드
3.4 상태 코드 
3.5 헤더 
3.6 추가 정보

4장 커넥션 관리 
4.1 TCP 커넥션 
4.2 TCP의 성능에 대한 고려
4.3 HTTP 커넥션 관리 
4.4 병렬 커넥션 
4.5 지속 커넥션 
4.6 파이프라인 커넥션 
4.7 커넥션 끊기에 대한 미스터리
4.8 추가 정보 


II. HTTP 아키텍처 

5장 웹 서버 
5.1 다채로운 웹 서버 
5.2 간단한 펄 웹 서버 
5.3 진짜 웹 서버가 하는 일 
5.4 단계 1: 클라이언트 커넥션 수락
5.5 단계 2: 요청 메시지 수신
5.6 단계 3: 요청 처리
5.7 단계 4: 리소스의 매핑과 접근
5.8 단계 5: 응답 만들기 
5.9 단계 6: 응답 보내기 
5.10 단계 7: 로깅 
5.11 추가 정보 

6장 프락시 
6.1 웹 중개자 
6.2 왜 프락시를 사용하는가? 
6.3 프락시는 어디에 있는가? 
6.4 클라이언트 프락시 설정 
6.5 프락시 요청의 미묘한 특징들 
6.6 메시지 추적 
6.7 프락시 인증 
6.8 프락시 상호운용성 
6.9 추가 정보 

7장 캐시 
7.1 불필요한 데이터 전송 
7.2 대역폭 병목 
7.3 갑작스런 요청 쇄도(Flash Crowds) 
7.4 거리로 인한 지연 
7.5 적중과 부적중 
7.6 캐시 토폴로지 
7.7 캐시 처리 단계 
7.8 사본을 신선하게 유지하기 
7.9 캐시 제어 
7.10 캐시 제어 설정 
7.11 자세한 알고리즘 
7.12 캐시와 광고 
7.13 추가 정보 

8장 통합점: 게이트웨이, 터널, 릴레이 
8.1 게이트웨이 
8.2 프로토콜 게이트웨이 
8.3 리소스 게이트웨이 
8.4 애플리케이션 인터페이스와 웹 서비스 
8.5 터널 
8.6 릴레이 
8.7 추가 정보 

9장 웹 로봇 
9.1 크롤러와 크롤링 
9.2 로봇의 HTTP 
9.3 부적절하게 동작하는 로봇들 
9.4 로봇 차단하기 
9.5 로봇 에티켓 
9.6 검색엔진 
9.7 추가 정보 

10장 HTTP/2.0 
10.1 HTTP/2.0의 등장 배경 
10.2 개요 
10.3 HTTP/1.1과의 차이점 
10.4 알려진 보안 이슈 
10.5 추가 정보 


III. 식별, 인가, 보안 

11장 클라이언트 식별과 쿠키 
11.1 개별 접촉 
11.2 HTTP 헤더 
11.3 클라이언트 IP 주소 
11.4 사용자 로그인 
11.5 뚱뚱한 URL 
11.6 쿠키 
11.7 추가 정보 

12장 기본 인증 
12.1 인증 
12.2 기본 인증 
12.3 기본 인증의 보안 결함 
12.4 추가 정보 

13장 다이제스트 인증 
13.1 다이제스트 인증의 개선점 
13.2 요약 계산 
13.3 보호 수준(Quality of Protection) 향상 
13.4 실제 상황에 대한 고려 
13.5 보안에 대한 고려사항 
13.6 추가 정보 

14장 보안 HTTP 
14.1 HTTP를 안전하게 만들기 
14.1.1 HTTPS 
14.2 디지털 암호학 
14.3 대칭키 암호법 
14.4 공개키 암호법 
14.5 디지털 서명 
14.6 디지털 인증서 
14.7 HTTPS의 세부사항 
14.8 진짜 HTTPS 클라이언트 
14.9 프락시를 통한 보안 트래픽 터널링 
14.10 추가 정보 388


IV. 엔터티, 인코딩, 국제화 

15장 엔터티와 인코딩 
15.1 메시지는 컨테이너, 엔터티는 화물 
15.2 Content-Length: 엔터티의 길이 
15.3 엔터티 요약 
15.4 미디어 타입과 차셋(Charset) 
15.5 콘텐츠 인코딩 
15.6 전송 인코딩과 청크 인코딩 
15.7 시간에 따라 바뀌는 인스턴스 
15.8 검사기와 신선도 
15.9 범위 요청 
15.10 델타 인코딩 
15.11 추가 정보 

16장 국제화 
16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원 
16.2 문자집합과 HTTP 
16.3 다중언어 문자 인코딩에 대한 지침 
16.4 언어 태그와 HTTP 
16.5 국제화된 URI 
16.6 기타 고려사항 
16.7 추가 정보 

17장 내용 협상과 트랜스코딩 
17.1 내용 협상 기법 
17.2 클라이언트 주도 협상 
17.3 서버 주도 협상 
17.4 투명 협상 
17.5 트랜스코딩 
17.6 다음 단계 
17.7 추가 정보 


V. 콘텐츠 발행 및 배포 

18장 웹 호스팅 
18.1 호스팅 서비스 
18.2 가상 호스팅 
18.3 안정적인 웹 사이트 만들기 
18.4 웹 사이트 빠르게 만들기 
18.5 추가 정보 

19장 배포 시스템 
19.1 배포 지원을 위한 FrontPage 서버 확장 
19.2 WebDAV와 공동 저작 
19.3 추가 정보 

20장 리다이렉션과 부하 균형 
20.1 왜 리다이렉트인가? 
20.2 리다이렉트 할 곳 
20.3 리다이렉션 프로토콜의 개요 
20.4 일반적인 리다이렉션 방법 
20.5 프락시 리다이렉션 방법 
20.6 캐시 리다이렉션 방법 
20.7 인터넷 캐시 프로토콜 
20.8 캐시 배열 라우팅 프로토콜 
20.9 하이퍼텍스트 캐싱 프로토콜 
20.10 추가 정보 

21장 로깅과 사용 추적 
21.1 로그란 무엇인가? 
21.2 로그 포맷 
21.3 적중 계량하기 
21.4 개인 정보 보호에 대해 
21.5 추가 정보 

---




# 1. HTTP 개관

## 리소스 
### 미디어 타입
- HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME TYPE<sup>Mulitipurpose Internet Mail Extensions</sup> 이라는 데이터 포맷 라벨을 붙이는데, 이메일에서 워낙 잘 동작했기 때문에, HTTP에도 채택.
- MIME 타입은 사선(/)으로 구분된 주 타입<sup>primary object type</sup> 과 부 타입<sup>specific subtype</sup>으로 이루어져 있음
```
- HTML 로 작성된 텍스트 문서는 text/html
- JEPG 이미지는 image/jpeg
- 애플 퀵타임 동영상은 video/quicktime
```

### URI
- 서버의 리소스 이름은 통합 자원 식별자<sup>uniform resource indentifier</sup>, 혹은 URI로 불림.
- URI 는 URN 과 URL 이 있음.

### URN
- 리소스를 여기저기로 옮기더라도 문제가 되지 않는데, 현재는 스펙만 있고, 여전히 실험중인 상태.

## 메시지 
- 메시지는 `시작줄`, `헤더`, `본문`으로 구성.

### 시작줄
- 메시지의 첫줄은 시작줄로, 요청이라면 무엇을 해야하는지, 응답이라면 무슨일이 일어났는지 나타냄.

### 헤더
- 헤더필드는 콜론(:) 으로 구분되어 있는 이름과 값으로 구성.
- 헤더는 빈 줄로 끝남.

### 본문
- 어떤 종류의 데이터를 담을 수 있는 본문

# 2. URL과 리소스

## 인터넷의 리소스 탐색하기 
- URL 은 URI 라고 불리는 더 일반화된 부류의 부분집합.

## URL 문법
- 대부분의 URL 스킴의 문법은 일반적으로 9개 부분으로 나뉨
```
<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

| 컴포넌트 | 설명 | 기본값 |
|:--------|:--------|:--------|
| **스킴** | 리소스를 가져오려면 어떤 프로토콜을 사용하며 서버에 접근해야 하는지를 가르킴 | 없음 |
| **사용자 이름** | 몇몇 스킴은 리소스 접근을 위해 사용자 이름을 필요로 함 | anonymous |
| **비밀번호** | 사용자의 비밀번호를 가리키며, 사용자이름에 콜론(:)으로 이어서 기술 | <이메일 주소> |
| **호스트** | 리소스를 호스팅하는 서버의 호스트명이나 IP 주소 | 없음 |
| **포트** | 서버가 열어놓은 포트번호 | 스킴에 따라 다름 |
| **경로** | 이전 컴포넌트와 / 로 구분되어 있으며, 서버 내 리소스가 어디 있는지 가리킴. 경로 컴포넌트의 문법은 **서버와 스킴**에 따라 다름. | 없음 |
| **파라미터** | 특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용. 이름/값 쌍으로 이루어 지며, 여러개의 값을 가질수 있음 | 없음 |
| **질의** | 스킴에서 애플리케이션에 파라미터를 전달하는데 사용. 질의 컴포넌트를 작성하는데 쓰이는 공통 포맷은 없음. 이는 URL 끝에 `?` 로 구분| 없음 |
| **프래그먼트** | 리소스의 조각이나 일부분을 가리키는 이름. URL이 특정 객체를 가리킬 경우, 프래그먼트 필드는 서버에 전달되지 않음. 클라이언트에서만 사용하는 컴포넌트로 `#` 으로 구분 | 없음 |



2.3 단축 URL
2.4 안전하지 않은 문자
2.5 스킴의 바다 
2.6 미래 
2.7 추가 정보



