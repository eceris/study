# 목차

- [1장 HTTP 개관]()
- [2장 URL과 리소스]()
- [3장 HTTP 메시지]()
- [4장 커넥션 관리]()

---
# 1. HTTP 개관

## 리소스 
### 미디어 타입
- HTTP는 웹에서 전송되는 객체 각각에 신중하게 MIME TYPE<sup>Mulitipurpose Internet Mail Extensions</sup> 이라는 데이터 포맷 라벨을 붙이는데, 이메일에서 워낙 잘 동작했기 때문에, HTTP에도 채택.
- MIME 타입은 사선(/)으로 구분된 주 타입<sup>primary object type</sup> 과 부 타입<sup>specific subtype</sup>으로 이루어져 있음
```
- HTML 로 작성된 텍스트 문서는 text/html
- JEPG 이미지는 image/jpeg
- 애플 퀵타임 동영상은 video/quicktime
```

### URI
- 서버의 리소스 이름은 통합 자원 식별자<sup>uniform resource indentifier</sup>, 혹은 URI로 불림.
- URI 는 URN 과 URL 이 있음.

### URN
- 리소스를 여기저기로 옮기더라도 문제가 되지 않는데, 현재는 스펙만 있고, 여전히 실험중인 상태.

## 메시지 
- 메시지는 `시작줄`, `헤더`, `본문`으로 구성.

### 시작줄
- 메시지의 첫줄은 시작줄로, 요청이라면 무엇을 해야하는지, 응답이라면 무슨일이 일어났는지 나타냄.

### 헤더
- 헤더필드는 콜론(:) 으로 구분되어 있는 이름과 값으로 구성.
- 헤더는 빈 줄로 끝남.

### 본문
- 어떤 종류의 데이터를 담을 수 있는 본문

# 2. URL과 리소스

## 인터넷의 리소스 탐색하기 
- URL 은 URI 라고 불리는 더 일반화된 부류의 부분집합.

## URL 문법
- 대부분의 URL 스킴의 문법은 일반적으로 9개 부분으로 나뉨
```
<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

| 컴포넌트 | 설명 | 기본값 |
|:--------|:--------|:--------|
| **스킴** | 리소스를 가져오려면 어떤 프로토콜을 사용하며 서버에 접근해야 하는지를 가르킴 | 없음 |
| **사용자 이름** | 몇몇 스킴은 리소스 접근을 위해 사용자 이름을 필요로 함 | anonymous |
| **비밀번호** | 사용자의 비밀번호를 가리키며, 사용자이름에 콜론(:)으로 이어서 기술 | <이메일 주소> |
| **호스트** | 리소스를 호스팅하는 서버의 호스트명이나 IP 주소 | 없음 |
| **포트** | 서버가 열어놓은 포트번호 | 스킴에 따라 다름 |
| **경로** | 이전 컴포넌트와 / 로 구분되어 있으며, 서버 내 리소스가 어디 있는지 가리킴. 경로 컴포넌트의 문법은 **서버와 스킴**에 따라 다름. | 없음 |
| **파라미터** | 특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용. 이름/값 쌍으로 이루어 지며, 여러개의 값을 가질수 있음 | 없음 |
| **질의** | 스킴에서 애플리케이션에 파라미터를 전달하는데 사용. 질의 컴포넌트를 작성하는데 쓰이는 공통 포맷은 없음. 이는 URL 끝에 `?` 로 구분| 없음 |
| **프래그먼트** | 리소스의 조각이나 일부분을 가리키는 이름. URL이 특정 객체를 가리킬 경우, 프래그먼트 필드는 서버에 전달되지 않음. 클라이언트에서만 사용하는 컴포넌트로 `#` 으로 구분 | 없음 |

## 단축 URL

### 상대 URL
- 기저 URL : 상대 URL 에서 기저가 되는 URL 로 html 에서 `<base>`태그로 지정할 수 있으며, 없는 경우에는 기본적으로 URL에서 가져와서 사용.

## 안전하지 않은 문자
- `이스케이프` 라는 기능을 이용하여 안전하지 않은 문자를 안전한 문자로 인코딩.

# 3. HTTP 메시지 

## 메시지의 흐름
- http 메시지는 애플리케이션 간에 주고 받은 데이터의 블록

## 메서드
- GET : 리소스를 달라고 요청하기 위해 사용.
- HEAD : GET처럼 행동하지만 서버는 응답으로 헤더만을 돌려줌.
- PUT : 서버에 문서를 쓰기 위해 사용.
- POST : 서버에 입력 데이터를 전송하기 위해 사용.
- TRACE : 목적지 서버에서 루프백 진단을 위해 사용.
- OPTIONS : 여러가지 종류의 지원 범위에 대해 물어보기 위해 사용.
- DELETE : 리소스를 삭제 하기 위해 사용.

## 상태 코드 
### 100 Continue 상태
- 요청의 일부가 시작되었으며, 클라이언틀가 나머지를 계속 이어서 보내야 함을 의미.

## 헤더

### 일반 헤더
| 헤더 | 설명 |
|:--------|:--------|
| **Connection** | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해준다. |
| **Date** | 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다. |
| **MIME-Version** | 발송자가 사용한 MIME 버전을 알려준다. |
| **Trailer chunked transfer** | 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열한다. |
| **Transfer-Encoding** | 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 말해준다. |
| **Upgrade** | 발송자가 업그레이드 하길 원하는 새 버전이나 프로토콜을 알려준다. |
| **Via** | 이 메시지가 어떤 중개자를 거쳐 왔는지 보여준다. |

- 캐시 헤더 

| 헤더 | 설명 |
|:--------|:--------|
| **Cache-Control** | 메시지와 함께 캐시 지시자를 전달하기 위해 사용. |
| **Pragma** | 메시지와 함께 지시자를 전달하는 또 다른 방법. 캐시에 국한되지 않음. |

### 요청 헤더
| 헤더 | 설명 |
|:--------|:--------|
| **Client-IP** | 클라이언트가 실행된 컴퓨터의 IP |
| **From** | 클라이언트 사용자의 메일 주소 제공 |
| **Host** | 요청의 대상이 되는 서버의 호스트명과 포트 |
| **Referer** | 현재의 요청 URI가 들어 있었던 문서의 URL을 제공 |
| **UA-Color** | 클라이언트 기기 디스플레이의 색상 능력에 대한 정보를 제공 |
| **UA-CPU** | 클라이언트 CPU의 종류나 제조사 |
| **UA-Disp** | 클라이언트의 디스플레이 능력에 대한 정보 제공 |
| **UA-OS** | 클라이언트 기기에서 동작중인 운영체제의 이름과 버전을 제공 |
| **UA-Pixels** | 클라이언트 기기 디스플레이에 대한 픽셀 정보 제공 |
| **User-Agent** | 요청을 보낸 애플리케이션의 이름을 서버에게 제공 |

- Accept 관련 헤더 : 서버에게 자신의 선호와 능력을 알려줌.

| 헤더 | 설명 |
|:--------|:--------|
| **Accept** | 클라이언트가 서버에게 보내도 되는 미디어 종류를 알려줌. |
| **Accept-Charset** | 클라이언트가 서버에게 보내도 되는 문자집합 종류를 알려줌. |
| **Accept-Encoding** | 클라이언트가 서버에게 보내도 되는 인코딩을 알려줌. |
| **Accept-Language** | 클라이언트가 서버에게 보내도 되는 언어를 알려줌. |
| **TE** | 클라이언트가 서버에게 보내도 되는 확장 전송 코딩을 알려줌. |

- 조건부 요청 헤더 : 예를 들어 클라이언트가 이미 문서의 사본을 갖고 있다면, 다를 경우에만 전송해달라고 조건부로 요청할 수 있다.

| 헤더 | 설명 |
|:--------|:--------|
| **Expect** | 클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해준다. |
| **If-Match** | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하는 경우에만 문서를 가져온다. |
| **If-Modified-Since** | 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한한다. |
| **If-None-Match** | 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져온다. |
| **If-Range** | 문서의 특정 범위에 대한 요청을 할 수 있게 해준다. |
| **If-Unmodified-Since** | 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한한다. |
| **Range** | 서버가 범위 요청을 지원한다면, 리소스에 대한 특정 범위를 요청한다. |

- 요청 보안 헤더 : 요청을 위한 간단한 인증체계를 갖고 있음.

| 헤더 | 설명 |
|:--------|:--------|
| **Authorization** | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있음. |
| **Cookie** | 클라이언트가 서버에게 토큰을 전달할 때 사용. 진짜 보안 헤더는 아니지만 보안에 영향을 줄 수 있다는 것은 확실하다. |
| **Cookie2** | 요청자가 지원하는 쿠키의 버전을 알려줄 때 사용. |

- 프락시 요청 헤더 : 프락시가 점점 흔헤지면서 그들의 기능을 돕기 위한 헤더.

| 헤더 | 설명 |
|:--------|:--------|
| **Max-Forwards** | 요청이 원 서버로 향하는 과정에서 다른 프락시나 게이트웨이로 전달될 수 있는 최대 횟수. TRACE 메서드와 함께 사용. |
| **Proxy-Authorization** | Authorization 과 같으나 프락시에서 인증할 때 쓰임. |
| **Proxy-Connection** | Connection 과 같으나 프락시에서 연결을 맺을 때 쓰임. |

### 응답 헤더
- 누가 응답을 보내고 있는지 혹은 응답자의 능력에 대해 알려주며, 응답에 대한 특별한 설명도 제공.

| 헤더 | 설명 |
|:--------|:--------|
| **Age** | 응답이 얼마나 오래되었는지 |
| **Public** | 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록 |
| **Retry-After** | 현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 혹은 시각 |
| **Server** | 서버 애플리케이션의 이름과 버전 |
| **Title** | HTML 문서에서 주어진 것과 같은 제목 |
| **Warning** | 사유 구절에 있는 것 보다 더 자세한 경고 메시지 |

- 협상 헤더 : 서버가 독일어와 영어로 번역된 html 문서를 제공한다면, 서버와 클라이언트가 어떤 표현을 택할 것 인지에 대한 협상을 할 수 있도록 지원.

| 헤더 | 설명 |
|:--------|:--------|
| **Accept-Ranges** | 서버가 자원에 대해 받아들일 수 있는 범위의 형태 |
| **Vary** | 서버가 확인해 보아야 하고 그렇기 때문에 응답에 영향을 줄 수 있는 헤더들의 목록 |

- 응답 보안 헤더 : HTTP 인증에서 응답측에 해당하는 헤더

| 헤더 | 설명 |
|:--------|:--------|
| **Proxy-Authenticate** | 프락시에서 클라이언트로 보낸 인증요구의 목록 |
| **Set-Cookie** | 진짜 보안헤더는 아니지만, 보안에 영향을 줄 수 있음. 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용. |
| **Set-Cookie2** | Set-Cookie와 비슷하게 RFC 2965로 정의된 쿠키. |
| **WWW-Authenticate** | 서버에서 클라이언트로 보내느 인증요구의 목록 |

### 엔터티 헤더
- 요청과 응답 모두 엔터티를 포함할 수 있으므로 광범위한 정보를 제공.

| 헤더 | 설명 |
|:--------|:--------|
| **Allow** | 이 엔터티에 대해 수행될 수 있는 요청 메서드들을 나열한다. |
| **Location** | 클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 말해줌.. |

- 컨텐츠 헤더 : 엔터티 컨텐츠에 대한 구체적인 정보를 제공. 웹 브라우저는 내용 유형을 기술한 Content-Type 헤더를 보고 그 객체를 어떻게 보여줄지 결정할 수 있음.

| 헤더 | 설명 |
|:--------|:--------|
| **Content-Base** | 본문에서 사용된 상대 URL을 계산하기 위한 기저 URL |
| **Content-Encoding** | 본문에 적용된 어떤 인코딩 |
| **Content-Language** | 본문을 이해하는데 가장 적절한 자연어 |
| **Content-Length** | 본문의 길이나 크기 |
| **Content-Location** | 리소스가 실제로 어디에 위치하는지 |
| **Content-MD5** | 본문의 MD5 체크섬 |
| **Content-Range** | 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 표현 |
| **Content-Type** | 이 본문이 어떤 종류의 객체인지 |

- 엔터티 캐싱 헤더 : 리소스에 대해 캐시된 사본이 아직 유효한 지에 대한 정보와 캐시된 리소스가 더이상 유효하지 않게 되는 시점을 잘 추정하기 위한 단서를 제공.

| 헤더 | 설명 |
|:--------|:--------|
| **ETag** | 이 엔터티에 대한 엔터티 태그 |
| **Expires** | 이 엔터티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
| **Last-Modified** | 가장 최근 이 엔터티가 변경된 일시 |


# 4. 커넥션 관리

## TCP 커넥션 
 
4.2 TCP의 성능에 대한 고려
4.3 HTTP 커넥션 관리 
4.4 병렬 커넥션 
4.5 지속 커넥션 
4.6 파이프라인 커넥션 
4.7 커넥션 끊기에 대한 미스터리
4.8 추가 정보 


















---


4장 커넥션 관리 
4.1 TCP 커넥션 
4.2 TCP의 성능에 대한 고려
4.3 HTTP 커넥션 관리 
4.4 병렬 커넥션 
4.5 지속 커넥션 
4.6 파이프라인 커넥션 
4.7 커넥션 끊기에 대한 미스터리
4.8 추가 정보 


II. HTTP 아키텍처 

5장 웹 서버 
5.1 다채로운 웹 서버 
5.2 간단한 펄 웹 서버 
5.3 진짜 웹 서버가 하는 일 
5.4 단계 1: 클라이언트 커넥션 수락
5.5 단계 2: 요청 메시지 수신
5.6 단계 3: 요청 처리
5.7 단계 4: 리소스의 매핑과 접근
5.8 단계 5: 응답 만들기 
5.9 단계 6: 응답 보내기 
5.10 단계 7: 로깅 
5.11 추가 정보 

6장 프락시 
6.1 웹 중개자 
6.2 왜 프락시를 사용하는가? 
6.3 프락시는 어디에 있는가? 
6.4 클라이언트 프락시 설정 
6.5 프락시 요청의 미묘한 특징들 
6.6 메시지 추적 
6.7 프락시 인증 
6.8 프락시 상호운용성 
6.9 추가 정보 

7장 캐시 
7.1 불필요한 데이터 전송 
7.2 대역폭 병목 
7.3 갑작스런 요청 쇄도(Flash Crowds) 
7.4 거리로 인한 지연 
7.5 적중과 부적중 
7.6 캐시 토폴로지 
7.7 캐시 처리 단계 
7.8 사본을 신선하게 유지하기 
7.9 캐시 제어 
7.10 캐시 제어 설정 
7.11 자세한 알고리즘 
7.12 캐시와 광고 
7.13 추가 정보 

8장 통합점: 게이트웨이, 터널, 릴레이 
8.1 게이트웨이 
8.2 프로토콜 게이트웨이 
8.3 리소스 게이트웨이 
8.4 애플리케이션 인터페이스와 웹 서비스 
8.5 터널 
8.6 릴레이 
8.7 추가 정보 

9장 웹 로봇 
9.1 크롤러와 크롤링 
9.2 로봇의 HTTP 
9.3 부적절하게 동작하는 로봇들 
9.4 로봇 차단하기 
9.5 로봇 에티켓 
9.6 검색엔진 
9.7 추가 정보 

10장 HTTP/2.0 
10.1 HTTP/2.0의 등장 배경 
10.2 개요 
10.3 HTTP/1.1과의 차이점 
10.4 알려진 보안 이슈 
10.5 추가 정보 


III. 식별, 인가, 보안 

11장 클라이언트 식별과 쿠키 
11.1 개별 접촉 
11.2 HTTP 헤더 
11.3 클라이언트 IP 주소 
11.4 사용자 로그인 
11.5 뚱뚱한 URL 
11.6 쿠키 
11.7 추가 정보 

12장 기본 인증 
12.1 인증 
12.2 기본 인증 
12.3 기본 인증의 보안 결함 
12.4 추가 정보 

13장 다이제스트 인증 
13.1 다이제스트 인증의 개선점 
13.2 요약 계산 
13.3 보호 수준(Quality of Protection) 향상 
13.4 실제 상황에 대한 고려 
13.5 보안에 대한 고려사항 
13.6 추가 정보 

14장 보안 HTTP 
14.1 HTTP를 안전하게 만들기 
14.1.1 HTTPS 
14.2 디지털 암호학 
14.3 대칭키 암호법 
14.4 공개키 암호법 
14.5 디지털 서명 
14.6 디지털 인증서 
14.7 HTTPS의 세부사항 
14.8 진짜 HTTPS 클라이언트 
14.9 프락시를 통한 보안 트래픽 터널링 
14.10 추가 정보 388


IV. 엔터티, 인코딩, 국제화 

15장 엔터티와 인코딩 
15.1 메시지는 컨테이너, 엔터티는 화물 
15.2 Content-Length: 엔터티의 길이 
15.3 엔터티 요약 
15.4 미디어 타입과 차셋(Charset) 
15.5 콘텐츠 인코딩 
15.6 전송 인코딩과 청크 인코딩 
15.7 시간에 따라 바뀌는 인스턴스 
15.8 검사기와 신선도 
15.9 범위 요청 
15.10 델타 인코딩 
15.11 추가 정보 

16장 국제화 
16.1 국제적인 콘텐츠를 다루기 위해 필요한 HTTP 지원 
16.2 문자집합과 HTTP 
16.3 다중언어 문자 인코딩에 대한 지침 
16.4 언어 태그와 HTTP 
16.5 국제화된 URI 
16.6 기타 고려사항 
16.7 추가 정보 

17장 내용 협상과 트랜스코딩 
17.1 내용 협상 기법 
17.2 클라이언트 주도 협상 
17.3 서버 주도 협상 
17.4 투명 협상 
17.5 트랜스코딩 
17.6 다음 단계 
17.7 추가 정보 


V. 콘텐츠 발행 및 배포 

18장 웹 호스팅 
18.1 호스팅 서비스 
18.2 가상 호스팅 
18.3 안정적인 웹 사이트 만들기 
18.4 웹 사이트 빠르게 만들기 
18.5 추가 정보 

19장 배포 시스템 
19.1 배포 지원을 위한 FrontPage 서버 확장 
19.2 WebDAV와 공동 저작 
19.3 추가 정보 

20장 리다이렉션과 부하 균형 
20.1 왜 리다이렉트인가? 
20.2 리다이렉트 할 곳 
20.3 리다이렉션 프로토콜의 개요 
20.4 일반적인 리다이렉션 방법 
20.5 프락시 리다이렉션 방법 
20.6 캐시 리다이렉션 방법 
20.7 인터넷 캐시 프로토콜 
20.8 캐시 배열 라우팅 프로토콜 
20.9 하이퍼텍스트 캐싱 프로토콜 
20.10 추가 정보 

21장 로깅과 사용 추적 
21.1 로그란 무엇인가? 
21.2 로그 포맷 
21.3 적중 계량하기 
21.4 개인 정보 보호에 대해 
21.5 추가 정보 

---

