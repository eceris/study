# 규칙 80. 익명클래스에 람다를 사용하자.

람다는 이름과 문서가 없기 때문에 computation 이 자기설명적이지 않거나, 3줄을 초과하면 람다에 넣지 마라.

1줄은 람다에게 이상적이지만 3줄은 reasonable 한 최대 사이즈이다. 만약 이 룰을 어길 경우 가독성에 심각한 ㅜㅁㄴ제가 생긴다.

만약에 람다가 길거나 읽기 어려운 경우 이것을 간단하게 할 방법을 찾거나 제거하라. 또한 열거형 생성자에 전달된 인수는 정적 컨텍스트에서 평가된다.

그러므로 enum 생성자의 람다는 enum의 인스턴스 멤버에 접근 불가. constant-specific class 바디는 이해하기 어렵거나, 몇줄에서 구현하기 어렵거나, 인스턴스필드나 메서드에 대한 액세스가 필요한 상수 관련 동작이 있는 경우에 사용가능.

마찬가지로, 람다 시대에는 익명클래스가 더이상 사용되지 않는다고 생각할 수 있다. 거의 사실에 가깝지만 람다가 아닌 익명클래스로만 할 수 있는 몇가지가 존재한다.
람다는 functional interfaces 로 제한된다. 만약 abstract 클래스의 인스턴스를 만들고 싶다면, 익명클래스로는 가능하지만 람다로는 불가능하다. 
이것과 비슷하게 익명클래스를 사용하여 여러개의 abstract 메소드가 있는 인터페이스의 인스턴스를 만들수 있다.
마지막으로 람다는 자기 자신의 참조를 얻을 수 없다. 람다에서 `this`키워드는 일반적으로 원하는 것을 둘러싸는 인스턴스를 참조한다. 익명 클래스에서 `this` 키워드는 익명클래스 인스턴스를 참조한다. 만약 본문 안에서 function 객체에 접근하려면 익명 객체를 사용해야 한다. 

람다는 익명클래스와 함께 구현 간에 안정적으로 직렬화 및 역직렬화 할 수없는 속성을 공유. 따라서 람다를 직렬화 하는 경우는 없다.
만약 `Comparator`와 같은 function 객체를 직렬화 하고 싶다면, private static nested class 의 인스턴스를 사용하라.

> 요약하자면, 자바 8에서 람다는 작은 function object를 나타내는 가장 좋은 방법이다. function object 를 표현하기위해 익명 클래스를 만들지 말라. 람다가 작은 function object 를 만드는데 적합하는 것을 기억하라.


  