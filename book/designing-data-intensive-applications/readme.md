# 1. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션

- 전체의 전형적인 응답시간을 알고 싶다면 *평균값* 은 좋은 지표가 되지 못함.
- 중앙값이 더 나은 지표.
- 아마존도 99.9분위를 최적화 하는 작업에 비용이 많이 들어, 집중하지 않음.

- 처리량(throughput)
	- 초당 처리할 수 있는 레코드 수나 일정 크기의 데이터 집합으로 작업을 수행할때 걸리는 전체 시간 
 	- 하둡과 같은 일괄처리 시스템에게 중요한 값.

- 응답시간(response time)
	- 클라이언트가 요청을 보내고 응답을 받는 사이의 시간. 
	- 온라인 시스템에서 중요한 값.

- 지연시간(latency)
	- 요청이 처리되길 기다리는 시간으로 서비스를 기다리며 휴지(latent) 상태인 시간을 말한다.

```
- 응답시간과 지연시간은 동일하지 않다. 응답시간은 클라이언트 관점에서 본 시간으로, 요청을 처리하는 실제 시간(서비스 시간) 외에도 네트워크 지연과 큐 지연도 포함한다.
- 응답시간은 자주 변하므로 단일 숫자가 아니라 측정 가능한 값의 분포로 생각해야한다. 응답시간중 가끔 튀는 시간이 있어 “전형적인” 응답 시간을 알고 싶다면 평균값은 좋은 지표가 아니다. 평균값 보다는 백분위를 사용하는 편이 더 좋다. 

- 예를 들어, 응답시간 중간값의 p95(95%), p99(99%) 백분위라면, 각각의 백분위가 중간값보다 빨리 처리된다
```


# 2. 데이터 모델과 질의 언어
- 일대다 , 일대일 관계를 매핑하기 위해서는 문서모델이 적합하지만, 다대다 관계인 경우 관계형 데이터베이스가 좋다.


# 3. 저장소와 검색

## 데이터베이스를 강력하게 만드는 데이터 구조
- 어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만듬. 데이터를 쓸 때마다 색인도 갱신해야 하기 때문인데, 보통은 개발자가 애플리케이션의 전형적인 질의 패턴을 활용해 수동으로 색인을 선택해야 함.

### SS테이블과 LSM 트리
- SS테이블 : 정렬된 문자열 테이블(sorted string table)로 세그먼트에 포함된 키로 정렬 된 테이블
- 항상 마지막에 추가된 세그먼트가 최신이 되지만, 쌓이기 때문에 컴팩션이 필요함.
- LSM트리 : 로그 구조화 병합트리(Log-Structured Merge-Tree)로 정렬된 파일 병합과 컴팩션 원리를 기반으로 함.

```
- 엘라스틱스치와 솔라에 사용하는 lucene도 용어 사전<sub>term dictionary</sub>을 저장하기 위해 유사한 방법을 사용. 
- 검색 질의로 단어가 들어오면 단어가 언급된 모든 문서의 ID 목록으로 하는 키-값 구조로 구현
```

### 성능 최적화
- 데이터베이스에 존재하지 않는 키를 조회 하기 위해 멤테이블을 확인하고 없으면 디스크에 읽기를 시도하는데, 이것을 방지하기 위해 존재하지 않는 키를 알려주는 은
### B트리
- 로그 구조화 색인은 수 메가바이트 이상의 가변크기를 가진 세그먼트를 기록하지만, B트리는 전통적으로 4KB 크기의 고정 크기 **블록** 이나 **페이지** 로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 함.

### 칼럼지향 저장소
- 모든 값을 하나의 로우에 저장하지 않고, 칼럼별로 값을 저장. 저장된 순서가 곧 인덱스 이므로, 접근이 빠름.
-


## OLTP(Online Transaction Processing) : 트랜잭션 최적화
- 사용자가 쌓는 데이터로 대량의 요청을 받을수 있어야 함. 읽기보다는 쓰기가 많고, 대게 디스크 탐색이 병목지점이다.


## OLAP(Online Aanlytic Processing) : 분석 최적화
- 데이터웨어하우스나 분석을 위한 시스템, OLTP보다 적은 수의 질의를 다루지만, 다루기 어렵고 짧은 시간에 수백만 개의 레코드를 스캔해야 함. 일반적으로 **디스크 대역폭**이 병목지점이며, 이러한 요구사항으로 인해 칼럼지향 저장소의 인기가 높아지고 있다.












