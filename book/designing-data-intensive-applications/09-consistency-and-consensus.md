# 09장 일관성과 합의

## 일관성 보장
- 복제 데이터베이스는 대부분 최종적 일관성을 제공.
- 최종적 일관성보다는 `수렴` 이 더 나은 이름일지도
- 언제 복제본이 수렴될지에 대해서는 아무도 얘기하지 않음.

## 선형성
- 원자적 일관성, 강한 일관성, 즉각 일관성, 외부 일관성 이라고도 함.
- 선형성은 최신성을 보장한다는 얘기

### 시스템에 선형성을 부여하는 것은 무엇인가?
- 선형성과 직렬성의 차이 
	- 직렬성 : 트랜잭션이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장.
	- 선형성 : 개별 객체에 실행되는 읽기와 쓰기에 대한 최신성 보장.

## 순서화 보장

### 순서화와 인과성
- 순서화가 인과성을 보존하는 데에 도움을 줌
- 인과성은 이벤트에 순서를 부여함. 시스템이 인과성에 의해 부여된 순서를 지키면 그 시스템은 `인과적으로 일관적`(causally consistent) 이라고 한다.

### 인과적 의존성 담기
- 어떤 연산이 다른 연산보다 먼저 실행됐는지 결정하는 기법이 필요.
- 버전 벡터를 사용.

### 일련번호 순서화
- 일련번호나 타임스탬프를 써서 이벤트의 순서를 정할 수 있음.(인과성에 일관적인)

### 전체 순서 브로드캐스트 사용하기
- 분산 시스템에서 순서화를 위해 노드사이에 메시지를 교환하는 프로토콜을 사용
- 노드나 네트워크에 결함이 있더라도 신뢰성과 순서화 속성이 항상 만족되도록 보장해야함.
- 모든 메시지가 데이터베이스에 쓰기를 나태내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제서버들은 일관성있는 상태를 유지(이 원리를 `상태기계 복제`(state machine replication) 라고 함.)

#### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기
- 결국은 compare-and-sat 혹은 increment-and-get 연산이 필요.

## 분산트랜잭션과 합의

- 단일 노드에서 트랜잭션 커밋은 데이터가 디스크에 지속성있게 쓰여지는 `순서` 에 결정적으로 의존
- 2PC(two phase commit) 도 코디네이터가 장애일 경우, 커밋포인트를 알수 없어 무한정 대기상태에 빠지는데, 이때 복구를 위해 참여자들에게 커밋, 어보트 요청을 보내기 전에 디스크에 트랜잭션 로그를 먼저 기록한다.
- 노드가 헬스여부를 구별할 수 있는 신뢰성있는 메커니즘(`perfect failure detector`)이 필요한데(실제로 아무 노드도 죽지 않았지만, 네트워크 문제로 인해 타임아웃될 수 있음.), 이것은 불가능한것 같음. 그래서 2PC가 문제가 있음에도 계속 쓰임.

### 현실의 분산 트랜잭션
- 여러 클라우드는 실제로 분산 트랜잭션이 낳는 여러 문제로 인해 분산 트랜잭션을 사용하지 않음.(mySql 에서는 분산 트랜잭션이 단일 노드 보다 10배 느리다고 보고됨)
- 이종 분산 트랜잭션은 다양한 방법으로 퉁합될 수 있으나 방법은 자세히 설명하지 않음.

#### XA 트랜잭션
- eXtended Architecture 는 이종 기술에 걸친 2phase commit 을 구현하는 표준.
- JTA(Java Transaction Api) 를 이용해 구현됨.
- 코디네이터가 장애에 빠진 경우, 고아가 된 트랜잭션은 관리자가 수동으로 처리하지 않은 한 복구할 수없음. 
- 여러 XA 구현에는 이런 상황에 경험적결정(heuristic decision) 이라 칭하는 비상 탈출구가 있다. 하지만 이것도 원자성을 깰 수 있다.


























