# 09장 일관성과 합의

## 일관성 보장
- 복제 데이터베이스는 대부분 최종적 일관성을 제공.
- 최종적 일관성보다는 `수렴` 이 더 나은 이름일지도
- 언제 복제본이 수렴될지에 대해서는 아무도 얘기하지 않음.

## 선형성
- 원자적 일관성, 강한 일관성, 즉각 일관성, 외부 일관성 이라고도 함.
- 선형성은 최신성을 보장한다는 얘기

### 시스템에 선형성을 부여하는 것은 무엇인가?
- 선형성과 직렬성의 차이 
	- 직렬성 : 트랜잭션이 어떤 순서에 따라 실행되는 것처럼 동작하도록 보장.
	- 선형성 : 개별 객체에 실행되는 읽기와 쓰기에 대한 최신성 보장.

## 순서화 보장

### 순서화와 인과성
- 순서화가 인과성을 보존하는 데에 도움을 줌
- 인과성은 이벤트에 순서를 부여함. 시스템이 인과성에 의해 부여된 순서를 지키면 그 시스템은 `인과적으로 일관적`(causally consistent) 이라고 한다.

### 인과적 의존성 담기
- 어떤 연산이 다른 연산보다 먼저 실행됐는지 결정하는 기법이 필요.
- 버전 벡터를 사용.

### 일련번호 순서화
- 일련번호나 타임스탬프를 써서 이벤트의 순서를 정할 수 있음.(인과성에 일관적인)

### 전체 순서 브로드캐스트 사용하기
- 분산 시스템에서 순서화를 위해 노드사이에 메시지를 교환하는 프로토콜을 사용
- 노드나 네트워크에 결함이 있더라도 신뢰성과 순서화 속성이 항상 만족되도록 보장해야함.
- 모든 메시지가 데이터베이스에 쓰기를 나태내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복제서버들은 일관성있는 상태를 유지(이 원리를 `상태기계 복제`(state machine replication) 라고 함.)

#### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기
- 결국은 compare-and-sat 혹은 increment-and-get 연산이 필요.

## 분산트랜잭션과 합의

- 단일 노드에서 트랜잭션 커밋은 데이터가 디스크에 지속성있게 쓰여지는 `순서` 에 결정적으로 의존
- 2PC(two phase commit) 도 코디네이터가 장애일 경우, 커밋포인트를 알수 없어 무한정 대기상태에 빠지는데, 이때 복구를 위해 참여자들에게 커밋, 어보트 요청을 보내기 전에 디스크에 트랜잭션 로그를 먼저 기록한다.
- 노드가 헬스여부를 구별할 수 있는 신뢰성있는 메커니즘(`perfect failure detector`)이 필요한데(실제로 아무 노드도 죽지 않았지만, 네트워크 문제로 인해 타임아웃될 수 있음.), 이것은 불가능한것 같음. 그래서 2PC가 문제가 있음에도 계속 쓰임.

### 현실의 분산 트랜잭션
- 여러 클라우드는 실제로 분산 트랜잭션이 낳는 여러 문제로 인해 분산 트랜잭션을 사용하지 않음.(mySql 에서는 분산 트랜잭션이 단일 노드 보다 10배 느리다고 보고됨)
- 이종 분산 트랜잭션은 다양한 방법으로 퉁합될 수 있으나 방법은 자세히 설명하지 않음.

#### XA 트랜잭션
- eXtended Architecture 는 이종 기술에 걸친 2phase commit 을 구현하는 표준.
- JTA(Java Transaction Api) 를 이용해 구현됨.
- 코디네이터가 장애에 빠진 경우, 고아가 된 트랜잭션은 관리자가 수동으로 처리하지 않은 한 복구할 수없음. 
- 여러 XA 구현에는 이런 상황에 경험적결정(heuristic decision) 이라 칭하는 비상 탈출구가 있다. 하지만 이것도 원자성을 깰 수 있다.


#### 내결함성을 지닌 합의
- 합의 알고리즘은 다음 속성을 만족해야함
	+ 균일한 동의(어떤 두 노드도 다르게 결정하지 않음)
	+ 무결성(어떤 노드도 두 번 결정하지 않음.)
	+ 유효성(한 노드가 값 v를 결정한다면, v는 어떤 노드에서 제안된 것.)
	+ 종료(죽지 않은 모든 노드는 결국 어떤 값을 결정.)
- 대부분의 합의 알리즘은 비잔틴 결함(메시지 신뢰)이 없다고 가정

#### 합의 알고리즘과 전체 순서 브로드캐스트
- 내결함성을 지닌 널리 알려진 합의 알고리즘 : 뷰스탬프 복제, 팍소스, 라프트, 잽


#### 단일 리더 복제와 합의
- 단일리더 복제(쓰기는 리더에, 그리고 읽기는 팔로워가) 는 결국 독재자 방식의 알고리즘(담당자가 리더를 결정하므로)
- 보통은 기존 리더에 장애가 발생하면, 팔로워 하나를 새리더로 승격시켜 장애를 극복, 
- 하지만 스플릿 브레인 문제(두개의 노드가 자신이 리더라고 주장하는)가 발생할 수 있음.

##### 에포크 번호 붙이기와 정족수
- epoch 내에서는 리더가 유일하다고 보장.
- 리더가 죽었다고 판단되면 투표가 시작됨. 이 선출은 epoch 번호를 증가시키며 두가지 다른 epoch 사이에 두 가지 다른 리더의 충돌이 있을 경우 epoch 번호가 큰 리더가 이김.(기존 리더는 죽었다고 판단했으나, 실제로 죽지 않았더라도..)
- 노드는 보통 epoch번호가 더 높은 다른 리더를 알지못할때만 제안에 찬성하는 투표를 함.
- 2pc 는 모든 노드로부터 "yes" 투표가 필요하지만, 합의 알고리즘은 과반수만 투표를 받으면 됨.

#### 합의의 제약
- 한대의 장애 내성을 갖추기 위해는 3대의 노드가 필요. 
- 두대의 장애 내성을 갖추기 위해서는 5대의 노드가 필요.(과반수를 형성을 위해)
- 클러스터에 노드를 동적으로 추가하는(동적 멤버십) 확장은 정적 멤버십 알고리즘보다 이해하기 어렵다.
- 합의 시스템은 장애노드 감지를 위해 타임아웃에 의존.(동적 멤버 추가로 인해 성능 문제를 유발할수 있음) 
- 그래서 네트워크 문제에 민감한데, 데이터 센터간에 클러스터링은 어렵다. 
- 예를 들어 라프트 알고리즘은 전체 네트워크중 하나의 네트워크 링크가 불안정 하다면, 리더십이 지속적으로 두 노드 사이를 왔다 갔다하는 엣지 케이스가 존재하는 것으로 알려짐.

### 멤버십과 코디네이션 서비스
- 주키퍼는 메모리에 데이터를 보관하도록 설계 되어있으며, 모든 노드에 브로드캐스트 알고리즘을 사용해 복제 됨. 
- 모든 복제본들이 선형적원자 연산(compare-and-set)을 사용해 잠금을 구현.

#### 작업을 노드에 할당하기
- 사람손을 타지 않고 자동으로 복구될수 있게 하는 아파치 큐레이터 같은 라이브러리가 있음에도 쉽지 않다.
- 주키퍼는 애플리케이션의 런타임 상태 저장용으로 의도된게 아님. 몇분 혹은 몇시간 단위로 변경될 수 있는 정보를 표현. 매초 수천번 혹은 수백만번을 위해 고려된 것은 아님.
- 애플리케이션 상태를 복제해야 한다면 아파치 북키퍼 같은 것을 사용.

#### 서비스 찾기
- 주키퍼, etcd, consul은 service discovery(특정 서비스에 연결하려면 어떤 ip 주소로 접속해야 하는지 알아내는 용도) 로 사용.
- 합의 시스템들 중에는 읽기 전용 캐시 복제 서버를 지원하기도 함.

#### 멤버십 서비스
- 멤버십 서비스는 클러스터에서 어떤 노드가 현재 활성화된 살아있는 멤버인지 결정.

# 정리
- 복제된 데이터가 오직 하나의 복사본만 존재하는 것 처럼 보이게 하고, 모든 연산을 원자적으로. 선형성은 이해하기 쉽지만 네트워크에 영향을 많이 받고 느리다는 단점이 있다.

- 시스템에서 발생한 이벤트에 순서를 부과하는 인과성은 선형성과 달리 더 약한 일관성 모델을 제공하지만 코디네이션 오버헤드가 없고, 네트워크 문제에 덜 민감.

- 분산노드 환경에서 인과적 순서를 담아내더라도, 유일성과 동시성을 보장하기는 쉽지 않고, 광범위한 문제가 실제로는 `합의` 로 환원될 수 있고, 서로 동일한 문제였음. 아래에 예시.
	+ 선형성 compare-and-set 레지스터 : 레지스터는 현재 값이 연산의 매개변수로 넘겨진 값과 같은지 여부에 따라 값을 설정할지 말지 원자적으로 `결정`해야 함.
	+ 원자적 트랜잭션 커밋 : 데이터베이스는 분산 트랜잭션을 커밋할 것인지 어보트할 것인지 `결정`해야 함.
	+ 전체 순서 브로드캐스트 : 메시징 시스템은 메시지를 전달할 순서를 `결정` 해야 함.
	+ 잠금과 임차권 : 여러 클라이언트들이 잠금이나 임차권을 얻기 위해 경쟁하고 있을 때 잠금은 누가 성공적으로 잠금을 획득할지 `결정`함.
	+ 멤버십/코디네이션 서비스 : 장애 감지기(예를 들어 타임아웃)가 주어지면 시스템은 어떤 노드는 살아 있고 어떤 노드는 세션 타임아웃이 발생해서 죽었다 고 생각돼야 하는지 `결정`해야 함.
	+ 유일성 제약 조건 : 여러 트랜잭션들이 동시에 같은 키로 충돌되는 레코드를 생성하려고 할 때 이 제약 조건은 어떤 것을 허용하고 어떤 것을 제약 조건 위반으로 실패하도록 할 것인지 `결정`해야 함.
	
- 위 상황을 처리하기 위해, `리더가 복구 될때까지 기다린다.`, `사람이 리더를 선정한다.`, `자동으로 새 리더를 선택하는 알고리즘을 사용한다.` 의 방법이 있음. 


























