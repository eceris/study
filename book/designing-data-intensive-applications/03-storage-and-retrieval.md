# 03장 저장소와 검색

## 데이터베이스를 강력하게 만드는 데이터 구조
- 색인은 기본 데이터에서 파생된 메타데이터.
- 어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 함.(색인을 갱신해야 하므로)

### 해시 색인
- 단순하게 키에 값을 매핑하는 형태(책에서는 메모리 오프셋 을 키로 사용)
- 파일이 커질 경우 세그먼트 단위로 컴팩션을 실행.(세그먼트 끼리도 병합)

### SS테이블과 LSM 트리
- SS(Sorted String)테이블 : 키로 정렬된 형식
- 정렬되어있으므로 모든 값에 대해 색인 하지 않아도 됨.(handiwork 를 찾기 위해 handbag 과 handsome 사이의 어딘가에 존재하므로)
- 쓰기 요청은 인메모리 balanced tree 데이터구조에 추가 한다.(인메모리트리를 memtable이라 칭함)
	+ memtable 이 수 메가바이트정도 의 임계치보다 커지면 SS테이플 파일로 디스크에 기록
	+ 트리가 이미 키로 정렬된 키-값 쌍을 유지하므로 효율적으로 실행 가능.
	+ SS테이블을 디스크에 기록하는 동안의 쓰기는 새로운 memtable에 수행
	+ 읽기 요청을 제공하려면 memtable에서 찾고 -> 디스크 상의 가장 최신 세그먼트 -> 그다음 오래된 세그먼트 순으로 찾음.
	+ 세그먼트 파일의 병합과 컴팩션은 백그라운드로 수행
- 문제로 데이터베이스가 셧다운 된 경우 메모리에 갖고 있던 정보를 잃지 않기 위해 별도의 로그로 순서 정렬없이 디스크에 기록도 해야함.
- `RocksDB`가 위와 같은 형태이다.
- 위와 같은 정렬된 파일 병합, 컴팩션 원리를 기반으로 하는 저장소 엔진을 `LSM 저장소` 엔진이라 칭함.

#### SS테이블에 에서 LSM 트리 만들기
- 루씬은 단어를 키, 값을 단어를 포함한 문서의 ID 목록 으로 하는 키-값 구조로 구현.

#### 성능최적화
- LSM 트리는 실제로 존재하지 않는 키를 탐색하는데 느림(memtable -> 디스크 확인을 해야 하므로)
	+ 이 문제를 해결하기 위해 보통 Bloom filte를 사용.
- 병합과 컴팩션의 전략은 크기계층(size-tiered) 과 레벨 컴팩션(leveled compaction)
- LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합, 컴팩션 하는 것.

### B 트리
- 가장 일반적인 색인 구조
- 