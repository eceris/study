시작하기 전에...
추천의 글
도메인 모델링에서는 개념과 구현을 분리해서는 안된다!

개발은 반복주기를 토대로 진행되어야 한다.
개발자와 도메인 전문가는 밀접한 관계에 있어야 한다. 

지속적인 리팩토링은 작은 재설계가 연속적으로 일어나는 것. 지나친 작업을 회피하려는 노력이 또 다른 두려움을 만들어 내기도 한다. 

1. 동작하는 도메인 모델 만들기(용어를 정의하고 도메인 모델의 사용이 미치는 영향에 대해…..)
2. 모델 주도 설계의 기본 요소(모델과 실제로 동작하는 소프트웨어 간극을 메우는데 방법에 대해..)
3. 더 심층적인 통찰력을 향한 리팩토링(탐구 과정에서 선택을 돕는 모델링 원칙과 방향을 제시하는 기법에 대해..)
4. 전략적 설계(복잡한 시스템, 외부 시스템과 상호작용에서 발생하는 상황에 대해...)


1부 동작하는 도메인 모델 만들기
모든 소프트웨어는 사용자의 활동이나 관심사와 관련되어 있다. 사용자가 프로그램을 사용하는 대상 영역이 바로 해당 소프트웨어의 도메인 이다.
모델과 핵심 설계는 서로 영향을 주며 구체화 된다.(모델을 이해한 것에 근거하여 코드를 해석)
모델은 팀 구성원이 사용하는 언어의 중추다.(모델과 구현이 연결되어 있으므로, 개발자와 도메인 전문가가 의사소통하는데 별도의 번역 절차가 필요하지 않다.)
모델은 지식의 정수만을 뽑아 낸 것이다.(모델은 도메인 지식을 조직화 하고 가장 중요한 요소를 구분하는 팀의 합의된 방식이다.)

NOTE
소프트웨어의 본질은 사용자를 위해 도메인에 관련된 문제를 해결하는 능력에 있고, 개발자는 업무 지식을 증진하기 위해 도메인 연구에 몰두해야 한다. 
하지만 대부분의 유능한 개발자는 특정 도메인을 학습하는데 관심이 많지 않으며, 자신의 기술력을 훈련할 수 있는 정량적인 문제를 좋아한다. 비록 도메인 업무가 무질서하고 컴퓨터 과학자로서의 능력에 보탬이 되지 않을 것 같은 복잡하고 새로운 지식을 많이 요구한다고 하더라도, 소프트웨어의 본질은 사용자의 문제를 해결하는 것이다!!!

지식 탐구
PCB 엔지니어들과 지속적인 소통으로 첫번째 클래스다이어그램을 얻을 수 있었고, 그것으로 프로토타입을 만들수 있었다. 프로토 타입을 통해 PCB 엔지니어들은 구체적인 피드백을 얻을수 있었다. 
지속적으로 PCB라는 모델을 정제하였고, 그와 함께 코드도 발전했다.

효과적인 모델링의 요소
모델과 구현의 연계(초기 프로토 타입을 토대로 연결고리를 만들고 유지.)
모델을 기반으로 하는 언어 정제(PCB엔지니어와 소프트웨어 개발자 간의 용어가 정제.)
풍부한 지식이 담긴 모델 개발(객체는 행위를 지니고 규칙을 이행하지만, 모델은 단순한 데이터 스키마가 아니라, 복잡한 문제를 해결하는 필수불가결한 것. 다양한 지식이 포함됨.)
모델의 정제(모델이 성숙하며, 본질적인 개념만 식별할 수 있는 모델로 ..)
브레인스토밍과 실험(수백가지의 변종 실험)
도메인 전문가와 프로그래머 모두 모델을 만들어 나가므로 모델은 명료하게 조직화되고, 추상화 될 수 있으며, 구현을 더 용이하게 만들어준다. 또한 도메인 전문가의 지속적인 관여로 심층적인 업무 지식을 반영하고, 추상회 된 개념은 참된 업무 원칙에 해당한다.
모델은 도메인을 이해하는데 실용적이고 유용해야 한다.

지속적인 학습
해당 도메인에 대해 우리는 스스로 얼마나 알지 못하는가를 깨닫지 못한다. 이러한 무지는 잘못된 가정으로 이어진다.(보통은 기술적으로 그다지 어려워 보이지 않는 도메인이 사람을 현혹시킨다.)
스스로 학습하는 팀원은 가장 핵심적인 부분을 개발하는 데 초점을 맞춘 고정 핵심 인력을 형성한다.

심층모델
보통 유용한 모델은 겉으로 들어나 있는 경우가 거의 없다. 처음에 중요하다고 생각했던 피상적인 모델 요소를 버리거나 관점을 바꾸는 경우가 오기도 한다. 이러한 지식탐구(과정)은 탐험과도 같아서 어디서 끝나게 될지 알지 못한다.

의사소통과 언어사용
용어와 상호관계는 기술적인 개발을 할 수 있을 만큼 충분히 정확한 동시에 도메인에 맞게 조정된 언어의 의미체계를 제공.(이는 모델을 개발 활동과 결부시키고 모델을 코드와 연계하는데 중요한 연결고리 역할을 한다.)
NOTE
일부 사람들만 쓰는 언어는 모두의 필요를 충족하지 못하므로 공통의 언어가 될 수 없다.
모델 기반 언어는 개발자 사이에서 시스템의 산출물 뿐 아니라 업무와 기능을 서술할 때에도 사용되어야 한다. 또한, 개발자와 도메인 전문가가 서로 의사소통 하는 것 뿐 아니라 서로의 요구사항, 개발 계획, 기능에서도 동일하게 사용되어야 한다. 언어(용어)는 중요하다.

중요!
모델을 언어의 근간으로 사용하라. 팀 내 모든 의사소통과 코드에서 해당 언어를 끊임 없이 적용하는데 전념하라. 다이어그램과 문서에서, 그리고 특히 말할 때 동일한 언어를 사용하라.
대안 모델을 반영하는 대안이 되는 표현을 시도함으로써 어려움을 해소해라. 그 다음, 새로운 모델에 맞게 클래스, 메서드 모듈의 이름을 다시 지으면서 코드를 리팩토링 하라.
이러한 언어(UBIQUITOUS LANGUAGE)의 변화가 곧 모델의 변화이다.
도메인 전문가는 도메인을 이해하는 데 부자연스럽고 부정확한 용어나 구조에 대해 반대해야하고, 개발자는 설계를 어렵게 만드는 모호함과 불일치를 찾아내는 데 신경써야 한다.

크게 소리내어 모델링 하기
모델을 정제하는 가장 좋은 방법은 가능한 모델 변형을 구성하는 다양한 요소를 큰 소리로 말하면서 살펴보는 것이다.

| 설명에 대한 평가 | 모델에 대한 설명 |
|:--------|:--------|
| 모호하고 기술적인 언어가 포함 | Routing Service 에 출발지, 목적지, 도착 시각을 전달하면 화물이 멈춰야 할 지점을 찾고, 그것을 데이터베이스에 삽입 |
| 위보다는 조금 더 낫지만, 장황하게 표현 | 출발지, 목적지, 등등 ... 이것들을 모두 Routing Service 에 넣으면 필요한 것이 모두 담긴 Itinerary를 반환 |
| 간결하고 분명함 | Routing Service 는 Route Specification 을 만족하는 Itinerary 를 찾는다 |

다이어그램을 그려서 시각적/공간적 추론 능력을 활용한 것이 중요한 것처럼 모델링에도 우리의 언어 능력을 사용해 곱씹어 보는 것도 중요하다.
시스템에 관해 이야기를 주고받을 때 모델을 사용하라. 모델의 요소와 상호작용을 이용하고 모델이 허용하는 범위에 개념을 조합하면서 시나리오를 큰 소리로 말해보라. 표현해야 할 것을 더 쉽게 말하는 방법을 찾아낸 다음 .. 그러한 새로운 아이디어를 다이어그램과 코드에 적용하라!!

한 팀, 한 언어
한 팀에 도메인 전문가와 개발자가 존재하고 두가지 언어를 혼용해서 사용한다면 잘못된 것이다. 만약 도메인 전문가에게 도메인모델을 보여줄 필요가 없다고 생각하고, 수준이 높은 도메인 전문가도 해당 모델을 이해하지 못한다면, 모델이 뭔가 잘못된 것이다.

도메인 모델은 통상 도메인 전문가의 전문용어에서 비롯되지만, 더 명료하고 한정된 정의로 정리될 것이다. 때로는 여러 언어가 필요할 때도 있지만, 도메인 전문가와 개발자 사이에 언어적 분열이 일어나서는 안된다.
UBIQUITOUS LANGUAGE의 영역에는 별개의 모델을 반영하면서 같은 도메인에서 쓰이는 대체 어휘가 포함되어서는 안된다. UBIQUITOUS LANGUAGE가 마련되면 개발자 간의 대화, 도메인 전문가 간의 논의, 코드 자체에 포함된 표현까지 이 모든 것이 공유된 도메인 모델에서 비롯된 동일한 언어를 기반으로 한다.

문서와 다이어그램
어떠한 설명을 할때 UML 다이어그램을 사용하고 설명을 덧붙이는 것이 좋을 수 있다. 사람에 따라 시각적인 정보를 더 빠르고 습득하는 사람들이 있기 때문이다. 다만, UML은 객체 간의 관계를 전달하는것을 잘 보여주지만, 객체의 개념적 정의를 보여주진 못한다.
사람들이 다양한 사고 실험을 시도하며 다이어그램은 변경될 수 있고, 밑그림은 유동성을 갖는 초기 그림이다. 어쨌든 UML은 통합 모델링 언어가 아니던가??!!!

UML 다이어그램은 모델의 가장 중요한 두가지를 보여줄수 없다.(모델이 나타내는 개념의 의미와 모델 안에서의 객체 행위를 보여주지 못한다.) UML은 간단한 밑그림 이고, 설계의 생생한 세부사항은 코드에 담긴다!!!!

모델은 다이어그램이 아니라는 점을 항상 명심하라. UML의 목적은 모델을 잘 설명하는 수단일 뿐, 잘 작성된 자바코드는 UML 만큼 표현력이 있다. 

글로 쓴 설계 문서
문서는 코드와 말을 보완하는 역할을 해야한다.(프로젝트의 흐름과 연관성을 잃어버리기 쉽다..즉,, 버전관리가 힘들다)
문서는 코드가 이미 잘하고 있는 것을 하려고 해서는 안된다.(세부사항에 대한 내용...은 문서에 포함하지 말자)
문서는 유효한 상태를 유지하고 최신 내용을 담고 있어야 한다.(필자는 다이어그램을 손으로 그리기도 한다. 딱딱하지도 않고 임시적이라는 느낌을 줄 수 있다.)
문서를 최소한으로 유지하고 코드와 대화를 보완하는데 집중하자. UBIQUITOUS LANGUAGE 와 그것의 발전이 문서를 유효한 상태로 유지하고 프로젝트 활동과 결부되게 만드는 구심점으로 삼자.


실행 가능한 기반
올바르게 실행되는 것뿐만 아니라 올바른 의미를 전달하는 코드를 작성하는 것은 엄청나게 세심한 노력을 기울여야한다.

설명을 위한 모델
설명을 위해서는 꼭 객체 모델일 필요도 없고 , 오히려 UML을 사용하지 않는 것이 좋다. 심지어 설명을 위한 모델과 설계를 주도하는 모델이 상응하는 경우가 있다고 하더라도, 정확하게 같지는 않다. 그리고 어렵다. 
예를 들면 클래스 다이어그램은 어떠한 도메인을 이해하는데 도움이 되지 않지만, 설명을 위한 모델은 자연어로 설명한 내용과 더불어 도메인 전문가와 개발자 모두에게 더 쉬운 이해를 도와준다.

모델과 구현의 연계
모델과 코드는 엄연히 다르지만, 둘 모두 중요하다. 여러 설계 방법론에서는 분석 모델의 필요성을 지지하는데, 이러한 분석을 별도의 과정이라고 생각하면 안된다. 
중요
설계 혹은 설계의 주된 부분이 도메인 모델과 대응하지 않으면 그 모델은 그다지 가치가 없으며 소프트웨어의 정확함도 의심스러워진다. 동시에 모델과 설계 기능 사이에 복잡한 기능은 서로 이해하기 힘들고, 설계가 변경되면 유지보수가 불가능해진다. 분석과 설계가 동떨어질 경우, 각자의 활동에서 얻은 지식이 서로에게 전해지지 않는다.

MODEL-DRIVEN DESIGN 에서는 분석모델과 설계를 나누지 않는다. 도메인 모델을 설계에 밀접하게 연관시키는 원칙을 강제하면, 가능한 각종 모델 가운데 좀 더 유용한 것을 선택하는 하나의 기준이 만들어진다. 이를 위해 많은 고민이 필요하고 보통은 수차례에 걸친 반복주기와 상당한 양의 리팩토링이 따르지만, 그 결과로 관련성 있는 모델이 만들어지게 된다.
개발은 모델, 설계, 코드를 단일한 활동으로 정제하는 반복적인 과정이다.

모델링 패러다임과 도구 지원
Java와 같은 언어라는 도구를 이용하여 모델링한다. 

HANDS-ON MODELER(실천적 모델러)
모든 팀원에게는 각기 전문화된 역할이 있지만 분석과 모델링, 설계, 프로그래밍에 대한 책임을 지나치게 구분하는 것은 MODEL-DRIVEN DESIGN 과 상충한다.

코드를 작성하는 사람이 모델에 책임감을 느끼지 못하거나 애플리케이션을 대상으로 모델이 동작하게 만드는 법을 모른다면 그 모델은 소프트웨어와 무관해진다. 코드를 변경하는 것이 곧 모델의 변경에 해당한다. 누가 좋아하건 말건 프로그래머가 곧 모델러다. 코드를 변경하는 책임이 있는 모든 이들은 코드를 통해 모델을 표현하는 법을 반드시 배워야 한다.
모델에 기여하는 사람들은 코드를 접하는 사람들과 UBIQUITOUS LANGUAGE를 토대로 모델의 아이디어를 나누는데 적극 참여해야 한다.

2부 모델 주도 설계의 기본 요소
도메인의 격리
도메인과 관련이 적은 기능으로부터 도메인 객체를 분리해야한다.(도메인 이라는 개념을 다른 기술과 혼동하거나, 헷갈리게 해서는 안된다.) 도메인의 격리를 위한 정교한 기법이 바로 LAYERED ARCHITECTURE 이다.

계층
설명
사용자 인터페이스
(표현 계층)
사용자에게 정보를 보여주고, 사용자의 명령을 해석하는 일을 책임진다. 간혹 사람이 아닌 다른 시스템이 외부 행위자가 되기도 한다.
응용계층
소프트웨어가 수행할 작업을 정의하고 표현력 있는 도메인 객체가 문제를 해결하게 한다. 이 계층에서 책임지는 작업은 업무상 중요하거나 다른 시스템의 응용계층과 상호작용 하는데 필요한 것 들이다. 이 계층은 얇게 유지된다. 여기에는 업무 규칙이나 지식이 포함되지 안ㄶ으며, 오직 작업을 조정하고 아래에 위치한 계층에 ㄷ포함된 도메인 객체의 협력자에게 작업을 위임한다. 응용 계층에서는 업무 상황을 반영하는 상태가 없지만 사용자나 프로그램의 작업에 대한 진행상황을 반영하는 상태를 가질 수는 있다.
도메인 계층
업무 개념과 업무 상황에 대한 정보, 업무 규칙을 표현하는 일을 책임진다. 이 계층에서는 업무 상황을 반영하는 상태를 제어하고 사용하며, 그와 같은 상태 저장과 관련된 기술적인 세부사항은 인프라스트럭처에 위임한다. 이 계층은 업무용 소프트웨어의 핵심이다.
인프라스트럭처 계층
상위 계층을 지원하는 일반화된 기술적 기능을 제공한다. 이러한 기능에는 애플리케이션에 대한 메시지 전송, 도메인 영속화, UI를 그리는 것 등이 있다. 또한 인프라스트럭처 계층은 아키텍처 프레임워크를 통해 네 가지 계층에 대한 상호작용 패턴을 지원할 수도 있다.
객체지향 프로그램에서는 종종 UI와 데이터베이스, 기타 보조적인 성격의 코드를 비지니스 객체 안에 직접 작성하기도 한다. 부가적인 업무로직은 UI 와 데이터베이스 스크립트에 들어간다. 이러한 일이 발생하는 이유는 단기적으로 이렇게 하는 것이 뭔가를 동작하게 하는 가장 쉬운 방법이기 때문이다.
도메인과 관련 없는 코드가 널리 확산될 경우, 코드를 확인하고 추론하기 굉장히 힘들어진다. 또한 UI를 표면적으로 변경하는 것이 실제 비지니스 로직을 변경하는 것으로 이어질 수 있다.

MODEL-DRIVEN DESIGN을 가능케 하는 것은 결정적으로 도메인 계층을 분리하는 데 있다.
중요
복잡한 프로그램을 계층으로 나눠라. 응집력 있고 오직 아래에 위치한 계층에만 의존하는 각 계층에서 설계를 발전시켜라. 상위계층과 결합을 느슨하게 유지하고, 도메인 모델과 관련된 코드는 모두 한 계층에 모으고, UI코드나 애플리케이션코드, 인프라스트럭처 코드와 격리하라.

예제
온라인 뱅킹 기능을 여러계층으로 나누기



소프트웨어에서 표현되는 모델
MODEL-DRIVEN-DESIGN 효과를 놓치지 않으면서 구현과 조화를 이루려면 기본적인 사항을 재구성할 필요가 있다. 모델과 구현은 상세 수준에서 연결되어야 한다.
여러 모델 요소 가운데 모델을 표현하는 3가지 패턴, 즉 ENTITY, VALUE OBJECT, SERVICE 를 구분하는데 초점을 맞춰 설명한다.
ENTITY : 어떤 객체가 연속성과 식별성(각종 상태를 바탕으로 추적되거나 서로 다른 구현에 걸쳐 존재하는 것)을 가진 경우
VALUE OBJECT : 다른 뭔가의 상태를 기술하는 속성에 불과..
SERVICE : 객체보다는 행동이나 연산으로 좀더 명확하게 표현….

연관관계
현실 세계에는 수많은 다대다(many to many) 연관관계가 있으며, 그중 상당수는 애초부터 양방향으로 나타난다. 이러한 일반적인 형태의 연관관계는 구현과 유지보수를 복잡하게 하며, 관계의 특성을 설명해주지 않는다.
연관관계를 쉽게 다루는 세가지 방법
탐색방향을 부여한다.
한정자(qualifier)를 추가해서 사실상 다중성(multiplicity)을 줄인다
중요하지 않은 연관관계를 제거한다.
애플리케이션 요구사항에서 두 방향을 모두 탐색할 필요가 없다면 탐색 방향을 제한해서 상호 의존성을 줄이고 설계를 단순화 할 필요가 있다. 다대다 연관관계의 탐색 방향을 제한하면 해당 연관관계는 사실상 훨씬 더 구현하기 쉬운 일대다 연관관계로 줄어든다.

ENTITY(엔티티, 참조객체라고도 함.)
어떤 객체를 일차적으로 객체의 식별성으로 정의할 경우, 그 객체를 ENTITY라고 한다. ENTITY는 자신의 생명 주기 동안 형태와 내용이 급격하게 바뀔 수도 있지만, 연속성은 유지해야 한다. ENTITY의 클래스정의와 책임, 속성, 연관관계는 ENTITY에 포함된 특정 속성보다는 ENTITY의 정체성에 초점을 맞춰야한다.
각 객체에 대해 유일한 결과를 반환하는 연산을 정의하라.(Java 의 Equals를 말하는 듯...)
식별 연산의 설계
각 ENTITY에는 다른 객체와 구분해줄 식별성(심지어 속성이 같은 다른 객체와도 구분할 수 있는...)을 만들어내는 수단이 분명히 있어야한다.(ID..) 객체지향 언어에는 객체의 메모리 주소를 비교해서 두 객체 참조가 같은 것을 가리키는지 판단하는 “동일성”연산이 포함되어있다.(Equals를 얘기 하는듯..) 그러나 이 정도의 식별성 관리만으로는 우리의 목적을 달성하기에 부족하다….어떤 객체는 여러 속성의 조합으로 식별성을 갖기도 하고, 시스템이 식별성을 보장하기 위해 ID를 자동으로 만들어 내기도 한다. 

VALUE OBJECT(값 객체)
개념적 식별성이 없는 객체도 많은데, 이러한 객체는 사물의 어떤 특징을 묘사한다. ENTITY의 식별성을 관리하는 일은 매우 중요하지만, 그 밖의 객체에 식별성을 추가한다면 시스템의 성능이 저하되고, 분석 작업이 별도로 필요하며, 모든 객체를 동일한 것으로 보이게 해서 모델이 혼란스러워 질 수 있다. 이러한 식별성이 없는 객체는 자체적인 특징을 비롯해 모델에 중요한 의미를 지니는데, 이것들이 바로 사물을 서술하는 객체이다.
중요
모델에 포함된 어떤 요소의 속성에만 관심이 있다면 그것을 VALUE OBJECT로 분류하라. VALUE OBJECT에서 전하는 속성의 의미를 표현하게 하고 관련 기능을 부여하라. 또한 불변적(Immutable)으로 다뤄라. VALUE OBJECT에 식별성을 부여하지 마라.
VALUE OBJECT를 구성하는 속성은 개념적으로 완전해야 한다.
VALUE OBJECT의 설계
여러 VALUE OBJECT 가운데 어느 것을 사용하는지는 중요하지 않다. 이런식으로 제약조건이 줄어들면 설계 단순화나 성능 최적화를 꾀할 수 있다. 하지만 여기에는 VALUE OBJECT의 복사, 공유, 불변성에 대한 의사결정이 따른다. VALUE OBJECT가 불변적인 한 변경관리는 단순해진다.(속성 값이 바뀌면 모두 바뀌어야 하기에 ..)
VALUE OBJECT를 활용하여 데이터베이스 최적화를 하는 사례도 있다.. 동일한 데이터에 대해 여러 개의 사본을 저장하는 이런 기법을 “역정규화” 라고 하며, 저장 공간이나, 유지보수의 단순함보다는 접근 시간이 더 중요한 경우에 종종 사용된다.(EX : USER의 생일과 같은….) 

SERVICE(서비스)
설계가 매우 명확하고 실용적이어도 개념적으로 어떠한 객체에도 속하지 않은 연산이 포함될 때가 있다. 이러한 문제를 억지로 해결하기보다는 문제 자체에 따라 SERVICE를 모델에 명시적으로 포함할 수 있다.

자신의 본거지를 ENTITY나 VALUE OBJECT에서 찾지 못하는 중요한 도메인 연산이 있는데, 이들 중 일부는 본질적으로 사물이 아닌 활동(activity)나 행동(action)인데, 우리의 모델링 패러다임이 객체이므로 이러한 연산이 객체와 잘 어울리게끔 노력해야 한다.

이따금 서비스는 특정 연산을 수행하는 것 이상의 의미없는 모델 객체(***manager 와 같은 것)로 나타나기도 하는데, 이러한 행위자(***manager or DOer)는 자신의 상태를 비롯해 도메인에서 맡고 있는 연산 이상으로는 어떠한 의미도 갖지 않는다.(제거해야할 대상이다..)

SERVICE는 상태를 갖지 않고, 다른 객체와의 관계를 강조한다. 잘 만들어진 SERVICE에는 아래의 세가지 특징이 있다. 
연산이 원래부터 ENTITY나 VALUE OBJECT의 일부를 구성하는 것이 아니라 도메인 개념과 관련되어 있다.
인터페이스가 도메인 모델의 외적 요소의 측면에서 정의된다.
연산이 상태를 갖지 않는다.(상태를 갖지 않는 다는 것은 클라이언트가 특정 SERVICE 인스턴스와 관계 없이 모든 접근 가능한 정보를 사용한다는 의미이다. -> 다시말해 side effect가 발생할 수 있다는 의미다.)

중요
도메인의 중대한 프로세스나 변환과정이 ENTITY나 VALUE OBJECT의 고유한 책임이 아니라면 연산을 SERVICE로 선언되는 독립 인터페이스로 모델에 추가하라. 대신 SERVICE는 상태를 갖지 않게 만들어라.

SERVICE와 격리된 도메인 계층
문헌 상에 논의되는 SERVICE는 대부분 순수하게 기술적이며 인프라스트럭처 계층에 속한다. 

서비스를 여러 계층으로 분할하기
응용
자금 이체 응용 서비스
입력(XML 요청과 같은) 내용의 암호화
이체처리를 위한 도메인 서비스로의 메시지 전송
이체 확인 대기
인프라스트럭처 서비스를 이용한 통지 결정

도메인
자금 이체 도메인 서비스
금액 인출/입금에 필요한 계좌와 원장 객체 간의 상호작용
이체 결과 확인 정보 제공(이체 수락 여부 등)

인프라스트럭처
통지 서비스
어플리케이션에서 지정한 곳으로 이메일이나 우편 등을 보냄

구성단위
SERVICE로 모델링 할때의 표현력에 비중을 두고는 있지만, 이 패턴은 ENTITY와 VALUE OBJECT로부터 클라이언트를 분리하는 것과 함께 도메인 계층의 인터페이스 구성 단위를 제어하는 수단으로서 가치가 있다.
도메인 서비스를 적절히 도입하면 계층 간의 경계를 선명하게 하는데 도움이 될 수 있다.

SERVICE에 접근하기
정교한 아키텍쳐는(정교하게 분할한 SERVICE 계층) 시스템을 분산하거나 프레임워크의 기능을 활용하고자 하는 실제 요구가 있을 때만 사용하자.(프로젝트가 지나치게 복잡해질 수도 있다!! 그러니까..적당히...)

MODULE(모듈, 패키지라고도 함)
사람들은 MODULE을 들여다 보지 않아도 MODULE의 세부사항을 보거나, MODULE에 들어있는 세부사항을 배제한 상태에서 MODULE간의 관계를 볼 수 있다.

리팩토링을 많이 하는 개발자도 프로젝트 초기에 생각한 MODULE에 만족하는 경향이 있다. 하지만, MODULE로 쪼개 지는것은 코드가 아닌 개념이다.(사람이 한번에 생각할 수 있는 양에는 한계가 있고, 일관성 없이 단편적인 생각은 헷갈리게 한다.)

중요
모듈간의 결합도를 낮추기 위해 시스템의 내력을 말해주는 MODULE을 골라 일련의 응집력 있는 개념들을 해당 MODULE에 담아라. 만약 그래도 단단하게 결합되어 있다면, 모델을 변경해서 얽혀 있는 개념을 풀어낼 방법을 찾아보거나, 다른 의미있는 방식으로 모델의 각 요소를 맺어줄 MODULE의 기준이 될 만한 개념을 찾아라. 높은 수준의 도메인 개념에 따라 모델이 분리되고 그것에 대응되는 코드도 분리될 때까지 모델을 정제하라.

개념적 관계를 살펴보는 것이 기술적 측정의 대안은 아니다. 개념적 관계를 살피는 것과 기술적 측정은 동일한 문제에 대해 각기 다른 수준에 있는 것 이므로 두가지 모두 이뤄져야 한다.

기민한 MODULE
MODULE을 변경하는 것은 어렵다.(범위가 넓을 뿐 아니라, 팀의 의사소통을 방해할 수도 있다.) 하지만, MODULE을 선택할 때 초기에 한 불가피한 실수로 결합도가 높아지면 리팩토링을 수행하기가 어려워진다. 리팩토링을 자주 수행하지 않는다면 상황은 점점 나빠질 것이다. 고통을 꾹 참고 경험을 바탕으로 문제가 있는 부분의 모듈을 재조직해야만 문제를 해결할 수 있다.

인프라스트럭처 주도 패키지화의 함정
패키지화를 바탕으로 다른 코드로부터 도메인 계층을 분리하라. 그렇게 할 수 없다면 가능한한 도메인 개발자가 자신의 모델과 설계 의사결정을 지원하는 형태로 도메인 객체를 자유로이 패키지화 할수 있게 하라.

모델링 패러다임
객체 패러다임이 지배적인 이유 - 객체 모델링이 복잡함과 단순함의 절묘한 조화를 이룰수 있다.(기술적으로 쉬워서도 아니고 객체 때문도 아니다.) 시간이 지나면서 군중이 움직이는대로 따라가면 얼마간은 안전하겠지만 그것이 언제나 정답은 아니다. 

객체 세계에서 객체가 아닌 것들
예를 들면 비객체 구성요소들(룰 엔진 혹은 워크플로 엔진)이 객체 시스템에 통합된다. 각각의 비객체 요소들은 각자의 패러다임이 존재하며, 성공적으로 객체로 캡슐화 하기에는 부자연스럽다. 하지만, 만약 룰 엔진이 구현의 표현력을 풍부하게 한다면 적절한 작은 프로그램에 가깝게 만들 수 있으며, 통합할 수 있다 …

객체가 아닌 요소를 객체지향 시스템에 혼합하는 데는 경험상 다음의 4가지 법칙이 있다.
구현 패러다임을 도메인에 억지로 맞추지 않는다.(도메인에 관한 사고방식은 반드시 하나만 있는 것은 아니다. 패러다임에 어울리는 모델 개념을 찾자.)
UBIQUITOUS LANGUAGE에 의지한다.(각종 도구가 서로 엄밀한 관계에 있지 않더라도 언어를 매우 일관되게 사용할 경우 설계의 각 부분이 분화되는 것을 방지할 수 있다.)
UML에 심취하지 않는다.(간혹 사람들이 UML 다이어그램과 같은 도구에 집착해서 그리기 쉬운 방향으로 모델을 왜곡하곤 한다. 다른 쉬운 그리기 방식이나 간단한 문장으로 설명을 써 놓는 편이 객체를 바라보는 특정 관점을 나타내는 좋은 방법이 될 수 있다.)
회의적이어야 한다.(도구가 실제로 제 몫을 하고 있는가? 단순히 어떤 규칙이 있다고 해서 값비싼 룰엔진을 사용해야만 하는 것은 아니다. 아마도 조금 덜 깔끔하겠지만 규칙은 객체로 충분히 표현 가능하며, 복합적인 패러다임은 문제를 너무 터무니없이 복잡하게 만든다.)

