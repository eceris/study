# 도메인 객체의생명주기
도메인 객체의 관리와 관련된 문제는 아래의 두 가지 범주로 나뉜다.
1. 생명주기 동안의 무결성 유지하기
2. 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지하기.
세가지 패턴으로 해결하는 데
AGGREGATE(집합체)는 소유권과 경계를 명확히 정의함으로써, 객체 간의 연관관계가 혼란스럽게 얽히지 않게 한다.
FACTORY(팩토리)를 이용해 복잡한 객체와 AGGREGATE를 생성하고 재구성함으로써 내부 구조를 캡슐화 하는 것으 관해...
REPOSITORY를 통해 거대한 인프라스트럭처를 캡슐화 하면서 영속 객체를 찾아 조회하는 수단을 제공.

## AGGREGATE(집합체)
모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기는 쉽지 않다.(개별 객체만이 아닌 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용되어야 하기 때문.) 그렇다고 변경의 일관성을 위해 Cautious locking scheme등을 사용한다면 다수의 사용자가 서로 부적절하게 간섭하여 시스템이 사용할 수 없는 상태가 된다.

모델 내의 참조에 대한 캡슐화를 추상화할 필요가 있다. AGGREGATE는 우리가 데이터 변경의 단위로 다루는 연관 객체의 묶음을 말한다. 

ENTITY와 VALUE OBJECT를 AGGREGATE로 모으고 각각에 대해 경계를 정의하라. 하나의 ENTITY를 지정하여 AGGREGATE의 루트로 만들고 AGGREGATE의 경계 내부의 객체에 대해서는 반드시 루트를 거쳐서 접근하도록 한다. 이러한 방식으로 AGGREGATE의 각 요소를 배치하면 AGGREGATE 안의 객체와 전체로서의 AGGREGATE의 상태를 변경할 때 모든 불변식을 효과적으로 이행할 수 있다.

```NOTE
AGGREGATE는 생명주기의 전 단계에서 불변식이 유지되어야 할 범위를 표시. 아래의 FACTORY와 REPOSITORY는 AGGREGATE를 대상으로 연산을 수행하며, 특정 생명 주기 전이에 따른 복잡성을 캡슐화 한다.
```

## FACTORY(팩토리)
어떤 객체나 전제 AGGREGATE를 생성하는 일이 복잡하거나 내부 구조를 너무 많이 드려내는 경우 FACTORY가 캡슐화를 도와준다.

예를 들면 자동차의 동작과 자동차의 조립은 관련성이 없다. 마찬가지로 복잡한 복합 객체를 조립하는 일은 조립이 완료되었을 때 해당 객체가 하는 일과 관련성이 적다. 그러나 객체의 조립과 같은 책임을 클라이언트로 옮긴다면 문제가 훨씬 나빠진다. 클라이언트에서 객체의 구조를 어느정도 알아야 하는데, 이렇게 되면 생성자를 호출 하는 것만으로도 결합된다. 

```NOTE
어떤 객체를 생성하는 것이 그 자체로도 주요한 연산이 될 수 있지만 복잡한 조립 연산은 생성된 객체의 책임으로는 어울리지 않는다. 
```

복잡한 객체와 AGGREGATE 의 인스턴스를 생성하는 책임을 별도의 객체로 옮겨라. 이 객체 자체는 도메인 모델에서 아무런 책임을 맡지 않을 수도 있지만 여전히 도메인 설계의 일부를 구성한다. 이렇게 복잡한 객체의 조립과정을 캡슐화 하는 동시에 인터페이스를 제공하라. 전체 AGGREGATE를 하나의 단위로 생성하여 불변하도록 하라.

FACTORY를 설계하는 방법에는 여러 가지가 있다.(FACTORY METHOD, ABSTRACT FACTORY, BUILDER)

### FACTORY와 FACTORY의 위치 선정
보통은 AGGREGATE의 루트에 FACTORY METHOD를 작성한다. 또는 생성된 객체를 소유하지는 않지만 다른 객체를 만들어내는 것과 밀접한 관련이 있는 객체에 FACTORY METHOD를 작성한다.

### 생성자만으로 충분한 경우
1. 클래스가 타입인 경우. 클래스가 어떤 계층 구조의 일부를 구성하지 않으며, 인터페이스를 구현 하는 식으로 다형적으로 사용되지 않는 경우
2. 클라이언트가 STRATEGY를 선택하는 한 방법으로서 구현체에 관심이 있는 경우
3. 클라이언트가 객체의 속성을 모두 이용할 수 있어서 클라이언트에게 노출된 생성자 내에서 객체 생성이 중첩되지 않는 경우
4. 생성자가 복잡하지 않은 경우
5. 공개 생성자가 FACTORY와 동일한 규칙을 반드시 준수해야 하는 경우. 

### 인터페이스 설계
FACTORY 메소드를 설계할 때에는 해당 FACTORY가 독립형이냐 FACTORY METHOD냐에 관계없이 아래 두 사항을 명심해야 한다.
1. 각 연산는 원자적이어야 한다. (필요한 것들을 모두 한번에 전달해야한다. 생성이 필패할 경우 예외를 던지거나 NULL을 반환하는 표준을 도입해서 전파하라.)
2. FACTORY는 자신에게 전달된 인자와 결합될 것이다.(객체 생성과정에 들어가는 인자는 강하게 결합된 인자이다.)

### 불변식 로직의 위치
FACTORY는 생성물과 특별한 관계를 맺는다. 이미 FACTORY는 생성물의 내부 구조를 알고 있으며 생성물에 대한 구현과 밀접하게 관련되어 있다. 특정 상황에서는 불변식 로직을 FACTORY에 둬서 생성물에 들어있는 복잡한 요소를 줄이는 이점도 있다. 

### ENTITY FACTORY와 VALUE OBJECT FACTORY
VALUE OBJECT FACTORY의 생성물(VALUE OBJECT)은 완전히 최종적인 형태로 만들어지므로 불변적이다.(그러므로 FACTORY의 연산은 생성물에 대한 풍부한 설명을 곁들여야 한다.)
ENTITY FACTORY는 유효한 AGGREGATE를 만들어 내는데 필요한 필수 속성만 받아들이는 경향이 있다. 또한 ENTITY에는 식별성을 할당해야 하므로 반드시 ID가 되는 값이 존재해야하며 FACTORY에서는 그것이 무엇이고 어디에 위치해야하는지 알고 있다.

### 저장된 객체의 재구성
재구성에 사용된 ENTITY FACTORY는 새로운 ID를 할당하지 않는다.(객체를 실체화 했던 것과의 연속성을 잃게 된다.)
객체를 재구성하는 FACTORY는 불변식 위반을 다른 방식으로 처리할 것이다.(새로운 객체를 생성하는 것 보다 훨씬 더 재구성을 어렵게 만들도록 하는 전략이 필요하다.)

FACTORY는 객체의 생성과 재구성이라는 생명주기 전이를 캡슐화 한다. 도메인 설계를 난해하게 할 수 있는 기술적 복잡성을 노출하는 또다른 생명주기는 REPOSITORY이다.(저장소에 들어갈때와 나갈때를 책임진다.) 

## REPOSITORY(레파지토리)
저장되어 있는 객체로부터 인스턴스를 만들어내는 것을 **재구성**이라고 한다. 마음대로 데이터베이스에 질의를 수행하면 실제로 도메인 객체와 AGGREEGATE의 캡슐화를 어길 수도 있다. 기술적 인프라스트럭처와 데이터베이스 접근 메커니즘을 드러내면 클라이언트가 복잡해져서 MODEL-DRIVEN DESIGN이 불분명해질 것이다. 

클라이언트는 단순하고 의도를 드러내는 인터페이스로 소통하고 모델의 측면에서 필요로 하는 것들을 요청할 수 있게 된다. 이러한 방법은 각 객체 타입에 대해 메모리상에 해당 타입의 객체로 구성된 컬렉션이 있다는 착각을 불러일으킬 정도이다. 잘 알려진 전역 인터페이스를 토대로 한 접근 방법을 마련하라. 객체를 추가하고 제거하는 메소드를 제공하고, 이 메서드가 실제로 데이터 저장소에 데이터를 삽입하고 제거하는 연산을 캡슐화 하게 하라. 

### REPOSITORY에 질의하기
프레임워크를 토대로 REPOSITORY를 일반화 하는 한가지 특별한 접근법은 **SPECIFICATION(명세)**에 기반한 질의를 사용하는 것이다. 이러한 방법은 우아하고 유연하다.
 
### REPOSITORY 구현
가장 이상적인 모습은 모든 내부 기능을 감춰서, 데이터 RDB 혹은 ODB 에 저장되든 단순히 메모리에 상주하던지 상관없이 클라이언트 코드를 동일하게 유지하는 것이다. 저장, 조회, 질의 메커니즘을 캡슐화 하는 것은 REPOSITORY 구현의 가장 기본적인 기능이다.

REPOSITORY 구현의 개념중 중요한 사항은 아래와 같다.
1. 타입을 추상화 한다.(REPOSITORY가 특정 타입의 모든 인스턴스를 담기는 하지만, 그것이 각 클래스마다 하나의 REPOSITORY가 필요하다는 얘기는 아니다.)
2. 클라이언트와의 분리를 활용한다.(REPOSITORY의 구현을 자유롭게 변경할 수 있다.) 
3. 트랜잭션 제어를 클라이언트에 둔다.(데이터의 삽입 삭제를 REPOSITORY에서 수행하겠지만, 보통 REPOSITORY에서는 아무도 커밋하지 않는다. 만약 REPOSITORY에서 간섭하지 않는다면 트랜잭션 관리가 단순해진다.)

### FACTORY와의 관계
FACTORY가 객체 생성의 초기를 다루는데 반해, REPOSITORY는 중간단계와 마지막 단계를 관리하는데 도움이 된다. 도메인 주도 관점에서 보면 FACTORY와 REPOSITORY의 책임이 뚜렷하게 구분되는데, FACTORY가 새로운 객체를 만들어낸다면, REPOSITORY는 기존 객체를 찾아낸다. 
FACTORY의 역할은 데이터를 가지고 잠재적으로 복잡한 객체를 인스턴스화 하는 것이다. 

사람들이 FACTORY와 REPOSITORY를 결합하게 만드는 또 한가지 경우는 **"찾아서 없으면 생성하는"** 기능을 원할 때 이다. 이 기능은 사용하는 것을 자제해야 한다.(기껏해야 조금 편리할 뿐이다.) **일반적으로 새로운 객체와 이미 존재하는 객체를 구분하는 것은 도메인에서 중요하다.**

### 관계형 데이터베이스를 위한 객체 설계
데이터베이스가 하나의 객체 저장소로 보여진다면 매핑도구의 기능과는 상관없이 데이터 모델과 객체 모델이 서로 갈라지게 해서는 안된다.(매핑 도구에 따라 일부 객체의 aggregation이나 composition으로 극복한다.)
객체 시스템외부의 프로세스는 객체 저장소에 접근해서는 안된다.(객쳋에 적용된 불변식을 위반할 수 있다.)

객체지향 도메인을 **영속적인 형태**로 표현하는 **관계형 데이터베이스**의 경우에는 단순하게 직접적으로 표현하는 것이 가능 좋다. 






