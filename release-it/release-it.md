# 3. 안정성 소개

- 엔터프라이즈 소프트웨어는 냉소적<sup>나쁜 일이 생길 거라 예상하고 그런일이 생겼을때 놀라지 않는</sup>이어야 한다. 
- **냉소적** 이어야 하는 이유는 단 기간의 비용 손해때문 만이 아니라 브랜드에 손상이 가기 때문

> 때문에 안정적인 소프트웨어가 중요하다. 놀라운 일은 안정적인 설계나 불안정적인 설계나 구현시에 비용은 거의 동일하다.

## 3.1 안정성이란?
- 일시적인 충격이나 지속적인 스트레스, 정상 처리를 방해하는 부품 고장이 있을 때라도 트랜잭션<sup>여기서 트랜잭션은 예를 들면, 옥션에서 `고객이 물건을 구매하는 것.` 이다.</sup>을 계속 처리하는 것.
- 기계 시스템에서 스트레스로 인해 형상의 변화가 생기는 것을 `스트레인` 이라고 하는데, 소프트웨어에도 마찬가지로 존재한다.
	- 어떤 모듈의 스트레인이 다른 시스템으로 전파 되기도 한다.

### 생명연장하기
- 시스템의 수명을 위협하는 주요 위험요소는 `메모리 누수` 와 `데이터 성장` 이다. 
- 메모리 누수와 같은 버그를 찾기는 굉장히 힘들기 때문에, 제이미터와 같은 부하테스트 도구를 사용하여 테스트하라. 
	- 힘들다면 적어도 중요한 부분은 테스트하라.

## 3.2 고장 유형
- 갑작스런 충격과 스트레인은 **크랙**을 발생시키기 시작하는데, 스트레스를 받을수록 더 빠른 속도로 전파.
- 이러한 크랙과 전파되는 방식, 손상된 결과를 **고장 유형** 이라고 한다. 
- 고장이 일어난다는 것을 받아들이고, 완충구간을 만들듯이 시스템의 나머지 부분을 보호하는 크랙 차단기<sup>crackstoppers</sup>를 설계 하자.

## 3.3 크랙 전파
- 2장의 CF프로젝트는 고장유형을 설계하지 않았다. 만약 설계 했다면 크랙이 전파되는 것을 막을 수 있었다.
	- 풀의 자원이 고갈되었을 때, 풀의 구성을 바꿀 수도 있었고,
	- 연결이 체크아웃 되었을때, 요청자를 영원히 블록하는 대신 제한된 시간동안 호출자를 블록하도록 설정할 수도 있었다.
	- RMI 를 사용하는 클라이언트에 소켓 타임아웃을 설정할 수도 있었고,
	- RMI 대신 웹서비스로 만들어서 HTTP 요청에 제한시간을 설정할 수도 있었다. 
- 더 큰 의미의 아키텍쳐 이슈로 보면, 메시지 큐를 사용해서 구현할 수도 있었다.

## 3.4 고장의 연쇄
- 동전 던지기<sup>이전의 결과가 현재의 결과에 영향을 미치지 않음</sup> 와는 반대로 장애의 원인은 독립적이지 않다.
	- 예를 들면, DB가 느려지면 어플리케이션의 메모리가 바닥날 가능성이 커진다.
- 결합이 긴밀할 수록 **크랙**을 가속한다.
	- 밀접하게 결합되어 있으면, 원격지의 장애가 현재 시스템의 정지 문제로 바뀌게 된다.
- 가능한 모든 고장에 대비하는 한가지 방법은 아래와 같이 모든 예상 결과를 생각해 보는 것이다.
	- 초기 접속을 못하면 어떻게 되는가?
	- 접속하는데 10분이 걸리면?
	- 접속 후 끊어지면?
	- 내 쿼리에 응답하는데 2분 이상 걸리면?
	- 동시에 만 개의 요청이 오게되면?
	- Exception 에 대한 메시지를 남기려하는데 디스크풀 이라면?
- 위와 같은 무지막지한 방법이 항상 살아있어야 하는 화성 탐사기 같은 시스템을 제외하면 비현실적이라고 생각할 수 있지만, 스트레스를 경감시키는 충격 흡수기는 꼭 필요하다.

## 3.5 패턴과 안티 패턴
