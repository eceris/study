# 3. 안정성 소개

- 엔터프라이즈 소프트웨어는 냉소적<sup>나쁜 일이 생길 거라 예상하고 그런일이 생겼을때 놀라지 않는</sup>이어야 한다. 
- **냉소적** 이어야 하는 이유는 단 기간의 비용 손해때문 만이 아니라 브랜드에 손상이 가기 때문

> 때문에 안정적인 소프트웨어가 중요하다. 놀라운 일은 안정적인 설계나 불안정적인 설계나 구현시에 비용은 거의 동일하다.

## 3.1 안정성이란?
- 일시적인 충격이나 지속적인 스트레스, 정상 처리를 방해하는 부품 고장이 있을 때라도 트랜잭션<sup>여기서 트랜잭션은 예를 들면, 옥션에서 `고객이 물건을 구매하는 것.` 이다.</sup>을 계속 처리하는 것.
- 기계 시스템에서 스트레스로 인해 형상의 변화가 생기는 것을 `스트레인` 이라고 하는데, 소프트웨어에도 마찬가지로 존재한다.
	- 어떤 모듈의 스트레인이 다른 시스템으로 전파 되기도 한다.

### 생명연장하기
- 시스템의 수명을 위협하는 주요 위험요소는 `메모리 누수` 와 `데이터 성장` 이다. 
- 메모리 누수와 같은 버그를 찾기는 굉장히 힘들기 때문에, 제이미터와 같은 부하테스트 도구를 사용하여 테스트하라. 
	- 힘들다면 적어도 중요한 부분은 테스트하라.

## 3.2 고장 유형
- 갑작스런 충격과 스트레인은 **크랙**을 발생시키기 시작하는데, 스트레스를 받을수록 더 빠른 속도로 전파.
- 이러한 크랙과 전파되는 방식, 손상된 결과를 **고장 유형** 이라고 한다. 
- 고장이 일어난다는 것을 받아들이고, 완충구간을 만들듯이 시스템의 나머지 부분을 보호하는 크랙 차단기<sup>crackstoppers</sup>를 설계 하자.

## 3.3 크랙 전파
- 2장의 CF프로젝트는 고장유형을 설계하지 않았다. 만약 설계 했다면 크랙이 전파되는 것을 막을 수 있었다.
	- 풀의 자원이 고갈되었을 때, 풀의 구성을 바꿀 수도 있었고,
	- 연결이 체크아웃 되었을때, 요청자를 영원히 블록하는 대신 제한된 시간동안 호출자를 블록하도록 설정할 수도 있었다.
	- RMI 를 사용하는 클라이언트에 소켓 타임아웃을 설정할 수도 있었고,
	- RMI 대신 웹서비스로 만들어서 HTTP 요청에 제한시간을 설정할 수도 있었다. 
- 더 큰 의미의 아키텍쳐 이슈로 보면, 메시지 큐를 사용해서 구현할 수도 있었다.

## 3.4 고장의 연쇄
- 동전 던지기<sup>이전의 결과가 현재의 결과에 영향을 미치지 않음</sup> 와는 반대로 장애의 원인은 독립적이지 않다.
	- 예를 들면, DB가 느려지면 어플리케이션의 메모리가 바닥날 가능성이 커진다.
- 결합이 긴밀할 수록 **크랙**을 가속한다.
	- 밀접하게 결합되어 있으면, 원격지의 장애가 현재 시스템의 정지 문제로 바뀌게 된다.
- 가능한 모든 고장에 대비하는 한가지 방법은 아래와 같이 모든 예상 결과를 생각해 보는 것이다.
	- 초기 접속을 못하면 어떻게 되는가?
	- 접속하는데 10분이 걸리면?
	- 접속 후 끊어지면?
	- 내 쿼리에 응답하는데 2분 이상 걸리면?
	- 동시에 만 개의 요청이 오게되면?
	- Exception 에 대한 메시지를 남기려하는데 디스크풀 이라면?
- 위와 같은 무지막지한 방법이 항상 살아있어야 하는 화성 탐사기 같은 시스템을 제외하면 비현실적이라고 생각할 수 있지만, 스트레스를 경감시키는 충격 흡수기는 꼭 필요하다.

## 3.5 패턴과 안티 패턴
- 대게 같은 트리거, 같은 파손, 전파 등으로 두번 이상 장애를 일으키진 않으나, 시간이 지나면서 패턴이 드러남.
- **안정성 패턴** 은 크랙이 `전파` 되는 것을 막아 주는데, 이것은 시스템이 붕괴되는 대신 손상된 채로 부분적인 기능을 유지하는데 도움을 준다.


# 4. 안정성 안티패턴

- 애플리케이션의 범위는 처음에 회사 안에서 시스템을 통합했지만, 근래에 들어서는 회사를 넘나들며 통합하고 있다.
- 이로 인해 다양한 고장유형을 만나게 되고, 작은 시스템보다 더 빨리 고장난다.
- `지나친 결합`은 시스템의 한 부분에 있는 크랙을 계층이나 시스템 경계를 넘어 다른 곳으로 전파시키거나 증가시킨다.

> 그러나 중요한 것은 모든 것이 고장나기 마련이라는 사실이고, 항상 최악을 가정하자는 것이다.

## 4.1 통합 지점
- `통합지점` 은 시스템을 죽이는 최고의 킬러다.
	- 모든 소켓, 프로세스, 파이프나 원격 프로시져 호출은 행이 걸리거나 걸릴 수 있으므로

### 소켓 기반 프로토콜
- 공유메모리와 named pipe 를 제외한 많은 것들이 소켓기반이며, 소켓 계층에서 발생한 고장에 영향을 받기 쉬움.
- Socket.setSoTimeout() 은 중요하다
- 네트워크 고장은 빠른 고장과 느린 고장이 있는데, 느린 고장은 좋지 않다.

#### 새벽 5시 문제
- 아무런 문제가 없는데 새벽 5시만 되면 행이 걸림.
- 소켓 연결은 추상화의 한 종류, 단순히 양 끝에 있는 컴퓨터의 메모리에 올라가있는 객체일 뿐.
	- 그래서 물리적인 연결이 끊어지더라도, 다시 연결가능하고
	- 양 끝에 있는 컴퓨터의 `연결`이 존재한다고 가정하면 `연결`은 지속된다. 
- 방화벽은 라우터일 뿐
	- 접근제어목록에 존재하는 연결일 경우, 패킷을 검사해서 거부, 무시 한다.
	- 연결될 경우 내부의 연결테이블에 저장.
- 물리적으로 연결이 끊어진 경우, 양 끝의 컴퓨터에게 연결이 끊어졌단는 것을 알릴 수 없음(TCP의 스펙의 한계)
- 양 끝에 있는 컴퓨터는 어떤 패킷도 받지 못한채 무한정 유효하다고 가정.
- JDBC 연결을 체크아웃하기 전에 ping query를 날리는데 이것 때문이었음.
	- 해결방안은 데이터베이스 서버가 제공하는 DCD<sup>dead connection detect</sup> 기능으로 클라이언트가 충돌한 것으로 판단되는 연결의 리소스를 해제한다.

### HTTP 프로토콜
- Apache Jakarta Commons 의 HttpClients 패키지는 연결 제한시간, 읽기 제한시간 등을 세밀하게 제어하는데, 이런 설정들이 냉소적인 시스템을 가능하게 한다.

### 벤더 API 라이브러리
- 벤더 API 라이브러리를 믿지 말자. 안전하지 않다. 
	- 보통은 내부 리소스 풀, 소켓 읽기 호출, HTTP 연결 등에 대한 문제가 많이 존재.
- 이러한 벤더 API에서 블록된다면 애플리케이션이 멈춘다.

### 통합지점 문제에 맞서기
- 테스트 하니스<sup>test harness</sup>를 통해 시스템과 네트워크 고장을 시뮬레이션 하자.
- JMeter 나 마라톤을 이용해 부하 테스트를 하자.

### 기억할 것
- 통합지점은 어떤식으로 고장나기 마련, 이런 고장에 대비하자.
- 통합지점의 고장에는 여러가지 형태가 존재하며, 이런 고장에 대비하자.
- 통합지점 고장에 경우 디버깅을 위해 추상화 계층을 들여다 보아야 하는데, 와이어샤크와 같은 네트워크 진단 툴이 도움이 되기도 한다.
- 원격지의 고장이 나의 문제가 되므로, 꼭 방어적으로 작성하자.
- 통합지점에서의 위험을 피하는데 도움이 되는 차단기, 제한시간, 미들웨어 등을 이용하여 방어적으로 프로그래밍 하자.

## 연쇄 반응
- 수평적 클러스터에서 단일지점 고장은 드물지만, 부하와 관련된 고장유형을 볼 수 있다.
- 첫번째 애플리케이션의 메모리 누수나 간헐적인 경쟁상태는 살아남은 노드에서도 나타날 가능성이 높다.

> - 알아야 할 것
	- 특정 계층에 의존하는 계층은 반드시 스스로를 보호할 것.
	- 메모리 누수는 연쇄 반응의 원인이 된다.
	- 트래픽도 모호한 경쟁상태를 일으키기도 한다. 
	- 연쇄반응을 막기 위해 차단기 패턴을 이용하자.

# 작성중