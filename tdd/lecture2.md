# JUnit과 Hamcrest

### 테스트 픽스처

일반적으로 소프트웨어 테스트에서 이야기하는 `테스트 픽스처`란 테스트를 **반복적으로** 수행할 수 있게 도와주고 매번 동일한 결과를 얻을 수 있게 도와주는 `기반이 되는 상태나 환경`을 의미한다. 일관된 테스트 실행환경이라고도 하며, 때로는 **테스트 컨텍스트**<sup>test context</sup>라 부르기도 한다.

#### 테스트 케이스 vs 테스트 메소드
테스트 케이스는 테스트 작업에 대한 시나리오적인 의미가 더 강하고 테스트 메소드는 JUnit의 메소드를 지칭한다. 그러나 테스트 케이스가 곧 테스트 메소드인 경우가 많기 때문에 두 단어는 종종 혼용되어 사용된다.

#### fail([message])
이 메소드가 호출되면 해당 테스트 케이스는 그 즉시 실패한다. 앞에서 테스트 케이스의 성공/실패 조건에서도 설명했지만, 현재 작성 중인 메소드의 경우 단정문을 쓰지 않았으면 예외가 발생하지 않는 이상 무조건 성공하는 테스트 케이스가 된다.
```java
public void testAccumulatedCharge() throws Exception {
	Charge charge = new Charge(this.year);
	chage.add(additionalFee);
	// 이하 계산 로직 미 작성 상태이므로 무조건 성공하는 테스트 케이스다.
}
```

#### 테스트 스위트 Test suite
여러 개의 테스트 케이스를 한꺼번에 수행하고자 할 때


#### JUnit 테스트 클래스에는 생성자가 없다?
JUnit 프레임워크는 Java의 리플렉션(reflection)을 사용해서 테스트메소드를 실행할 때마다 테스트 클래스를 강제로 인스턴스화한다. 왜 그랬을까? 왜 테스트 메소드를 실행할 때마다 객체를 새로 만들어내는 것일까? 좋은 테스트 케이스는 기본적으로 다른 테스트 케이스의 수행이나 수행 결과에 영향을 받지 않아야 한다. 이것이 테스트의 기본 원칙이다. 따라서 각각의 테스트 케이스를 독립적으로 수행하기 위해, 테스트 메소드 수행 전에 테스트 클래스 자체를 리셋한다. 그런 다음 각각의테스트 메소드만 수행하는 식으로 다른 테스트 메소드들로 인한 영향을 최소화한다.


#### JUnit 4의 특징

1. Java 5 애노테이션 지원
2. test라는 글자로 method 이름을 시작해야 한다는 제약 해소
```
Test 메소드는 \@Test를 붙인다.
```
3. 좀 더 유연한 픽스처
```java
@BeforeClass, @AfterClass, @Before, @After
```
4. 예외 테스트
```java
@Test(expected=NumberFormatException.class)
```
5. 시간 제한 테스트
```java
@Test(timeout=1000)
```
6. 테스트 무시
```java
@Ignore("this method isn't working yet")
```
7. 배열 지원
```java
assertArrayEquals([message], expected, actual);
```
8. \@RunWith(클래스이름.class)
```
JUnit Test 클래스를 실행하기 위한 러너(Runner)를 명시적으로 지정한다.
@RunWith는 junit.runner.Runner를 구현한 외부 클래스를 인자로 갖는다.
```
9. \@SuiteClasses(Class[])
```
보통 여러 개의 테스트 클래스를 수행하기 위해 쓰인다. @RunWith를 이용해 Suite.
class를 러너로 사용한다.
```
10. 파라미터를 이용한 테스트
```java
@RunWith(Parameterized.class)
@Parameters
public static Collection data() {
	...
}
```

### 좋은 코드? 나쁜 코드?
> 좋은 소스와 그렇지 않은 소스를 구분하는 방법은 무엇일까? 여러 가지 기준이 있을 수 있겠지만, 가장 쉬운 권장 방법은 어떤 코드가 자연스럽게 읽힐 수 있는지 살펴보는 것이다. 무슨 말인가 하면, 소스코드를 볼 때 한 줄 한 줄의 의미를 생각하며 따라가는 식으로 ‘분석한다’는 느낌이들면 좋지 않은 소스, 소설책 읽듯이 문맥을 갖고 ‘쉽게 읽힌다’면 좋은 소스로 구분하는 것이다. 우리가 ‘소스코드’라는 걸 작성하는 목적이자, 프로그래밍 언어가 계속 발전하는 중요한 이유 중 하나는, 컴퓨터와 좀 더 잘 대화하기 위해서가 아니라 다른 사람들과 좀 더 잘 대화하기 위해서 라는 사실을 잊지 말자.
