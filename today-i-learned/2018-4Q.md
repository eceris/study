
# 11/19
첫 출근. 밝고 에너지 넘친다. 
다만, 적응하는데 시간이 필요한 몇가지가 있었음. 맥북, 망분리된 개발환경...등등.. **화이팅!**

# 11/01

#### [Josh Long의 Spring 5.0dptj 신박하게 빈 등록하는 방법](https://www.infoq.com/presentations/bean-registration-spring-5#)
functional하게 람다식을 사용해서 빈을 등록하는 방법 소개..

기존에 annotation을 사용하던 방법
```java
@SpringBootApplication
public class VintageStyle {

    public static void main(String[] args) {
        SpringApplication.run(VintageStyle.class, args);
    }

    @Bean
    RouterFunction<?> routes() {
        return route(GET("/hi"), req -> ok().body(Mono.just("hi hello"), String.class));
    }

    @Bean
    CustomerService customerService(MongoClient mongoClient) {
        return new CustomerService(mongoClient);
    }

    @Bean
    ApplicationRunner runner(CustomerService customerService) {
        return args -> System.out.println(customerService.toString());
    }
}
```
Josh가 알려준 방법
```java
@SpringBootApplication
public class Spring5Style {
    public static void main(String[] args) {
        new SpringApplicationBuilder()
                .sources(Spring5Style.class)
                .initializers((ApplicationContextInitializer<GenericApplicationContext>) ctx -> {
                    ctx.registerBean(CustomerService.class);
                    ctx.registerBean(ApplicationRunner.class, () -> args1 -> System.out.println(ctx.getBean(CustomerService.class).toString()));
                    ctx.registerBean(RouterFunction.class, () -> route(GET("/hi"), serverRequest -> ok().body(Mono.just("test"), String.class)));
                })
                .run(args);
    }
}
```

# 10/30

#### TDD 실천법과 도구 8장 : [TDD에 대한 다양한 시각](https://github.com/eceris/study/blob/master/tdd/lecture8.md)
테스트코드의 대상이 되는 클래스의 한부분을 바꿨더니 테스트 케이스가 우르르르르르 다 실패했어요!

> 의존 관계가 많은 코드는 테스트 코드 자체를 만들기가 어렵다. 즉 테스트 케이스가 우르르 다 실패한 이유는 의존관계가 많아서이다.....

#### 리액티브 프로그래밍 [Adapt 동영상](https://www.youtube.com/watch?v=AXwZgh3cAh0)
rxJava <-> reactor 이것저것 서로 변환하는 것.
이걸 쓸 일이 있을까 싶지만.....

##### flux <-> flowable
```java
@Test
public void flux_to_flowable() {
    Flux<Integer> flux = Flux.just(2);
    Flowable<Integer> flowable = Flowable.fromPublisher(flux);
}

@Test
public void flowable_to_flux() {
    Flowable<Integer> flowable = Flowable.fromPublisher(Flux.just(2));
    Flux<Integer> flux = Flux.from(flowable);
}
```

##### flux <-> observable
```java
@Test
public void flux_to_observable() {
    Flux<Integer> flux = Flux.just(2);
    Observable<Integer> observable = Observable.fromPublisher(flux);
}

@Test
    public void observable_to_flux() {
        Observable<Integer> observable = Observable.just(2);
        Flux<Integer> flux = Flux.from(observable.toFlowable(BackpressureStrategy.BUFFER));
    }

```

##### mono <-> single
```java
@Test
public void mono_to_single() {
    Mono<Integer> mono = Mono.just(2);
    Single<Integer> single = Single.fromPublisher(mono);
}

@Test
public void single_to_mono() {
    Single<Integer> single = Single.just(2);
    Mono<Integer> mono = Mono.from(single.toFlowable());
}
```

##### mono <-> completableFuture
```java
@Test
public void mono_to_completableFuture() {
    Mono<String> mono = Mono.just("Hello").map(s -> s.toUpperCase());
    CompletableFuture<String> future = mono.toFuture();
}

@Test
public void completableFuture_to_mono() {
    CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> "Hello");
    future.thenApply(s -> s.toUpperCase());
    Mono<String> mono = Mono.fromFuture(future);
}
```

# 10/26

[TDD](https://ko.wikipedia.org/wiki/%ED%85%8C%EC%8A%A4%ED%8A%B8_%EC%A3%BC%EB%8F%84_%EA%B0%9C%EB%B0%9C)에 대해 어렴풋이 알고 있던 지식을 확실하게 하고 싶어 검색 중 절판된 **TDD 실천법과 도구** 라는 책을 [PDF](https://repo.yona.io/doortts/blog/issue/1)로 구할 수 있었다. 조금 된 책이지만, 원하는 정도의 정보는 얻을수 있고, 그간의 역사? 를 알수 있지 않을까해서.... 읽기 시작..하였고, [정리도....한다.](https://github.com/eceris/study/tree/master/tdd)

# 10/12

[R2DBC](https://github.com/r2dbc) Reactive Relational Database Connectivity 라는 RDB인데 Reactive를 지원하는 라이브러리이다. 기본적으로 1.0.x 버전은 쓰지 말라는 말이 맞는 것 같다. 기본적으로 동작하긴 하지만, 알 수 없는 예외가 많이 발생한다. 샘플링 코드는 [여기](https://github.com/eceris/study/blob/master/reactive/coffee-service/src/main/java/kr/co/eceris/r2dbc/coffeeservice/CoffeeServiceApplication.java)를 참고.

# 10/04

[Generic의 TypeErasure](https://github.com/eceris/study/blob/master/typetoken/README.md)에 대해 좀 알아봤다. 아직도 모르는 것이 많은데, 자바를 알고 있다고 말할 수 있을까?

# 10/01

좀 삽질했는데.... 이거.... Getter 없으면 HttpMessageNotWritableException 에러남.

```
org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: No serializer found for class com.daou.go.core.domain.FcmDevice$Presentation and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS); nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class com.daou.go.core.domain.FcmDevice$Presentation and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.daou.go.core.controller.api.model.ResponseWrapper["data"])
```

