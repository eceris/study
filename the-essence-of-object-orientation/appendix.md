# 추상화 기법
추상화는 도메인의 **복잡성** 을 단순화하고 직관적인 **멘탈 모델**을 만드는데 사용할 수 있는 가장 기본적인 인지 수단.

##### 추상화 기법의 종류

- 분류와 인스턴스화 : **분류** 는 객체의 구체적인 세부사항을 숨기고 인스턴스 간 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정. 분류의 역은 **인스턴스화** 과정.
- 일반화와 특수화 : **일반화** 는 범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 **강조**. 일반화의 역은 **특수화** 과정.
- 집합과 분해 : **집합** 은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정. 집합의 반대 과정은 부분으로 분리하는 **분해** 과정.

### 분류와 인스턴스화

##### 개념과 범주
- 객체를 **분류**하고 범주로 묶는 것은 객체들의 특정 집합에 공통의 **개념**을 **적용**하는 것을 의미. **개념** 이란 속성과 행위가 유사한 객체에 **공통**적으로 적용되는 **관념** 이나 **아이디어**.

> 세상에 존재하는 객체에 개념을 적용하는 과정을 **분류**라고 한다. 

> \- Martin 1998

수많은 개별적인 현상들을 **객체** 라고 하고, 하나의 개념을 **타입** 이라고 한다.

```
객체 : sm5, 소나타, k5
타입 : 자동차
```
> 객체지향 세계에서 **개념** 을 가리키는 표준용어는 **타입** 이다.

> \- Martin 1998

**분류**는 **객체**와 **타입** 간의 **관계**를 나타낸 것. 어떤 객체가 타입의 정의에 부합할 경우 객체는 해당 타입으로 분류, 자동으로 **타입**의 **인스턴스**가 된다.


##### 타입

객체를 타입에 따라 분류하기 위한 관점
1. 심볼 : 타입을 가리키는 간단한 이름이나 명칭
2. 내연 : 타입의 완전한 정의, 내연의 의미를 이용해 객체가 타입에 속하는 지 여부를 확인할 수 있다.
3. 외연 : 타입에 속하는 모든 객체들의 집합

##### 외연과 집합
타입의 외연은 타입에 속하는 객체들의 집합.

단일 분류<sup>single classification</sup> 와 다중 분류<sup>multiple classification</sup> 라는 것이 있는데, 보통 대부분의 객체지향 프로그래밍 언어들은 단일 분류만 지원.<sup>오직 한 클래스의 인스턴스</sup>

동적 분류<sup>dynamic classification</sup>와 정적 분류<sup>static classification</sup> 라는 것이 있는데, 프로그래밍 언어에서는 정적 분류의 방법만 제공.<sup>클래스로부터 인스턴스를 생성한 이후에 클래스를 변경할 수 없음.</sup>

##### 클래스
타입을 구현하는 가장 보편적인 방법은 객체지향 프로그래밍 언어를 이용해 클래스로 구현하는 것.
**타입**과 **클래스**는 다른데, 클래스는 타입을 구현하는 용도 외에도 **코드를 재사용하는 용도**로도 사용. 클래스 외에도 인스턴스 생성이 불가한 **추상클래스**나 **인터페이스**를 사용해 타입을 구현 가능.

클래스가 없는 프로토 타입 언어<sup>javascript 같은...</sup> 에서 분류와 인스턴스화는 **프로토타입** 이라는 객체의 **복사** 를 통해 이뤄진다.

### 일반화와 특수화

##### 범주의 계층
범주에는 계층이 있는데 좀 더 세부적인 범주가 계층의 하위에 위치, 더 일반적인 범주가 계층의 상위에 위치. 
1. 상위에 위치한 범주를 하위에 위치한 범주의 **일반화**.
2. 하위에 위치한 범주를 상위에 위치한 범주의 **특수화**.

##### 서브 타입
어떤 타입이 다른 타입보다 일반적이면, 이 타입을 슈퍼타입<sup>supertype</sup> 이라고 하고,
어떤 타입이 다른 타입보다 좀 더 특수하다면, 서브타입<sup>subtype</sup> 이라고 한다.

객체의 집합을 나타내는 외연의 관점에서 **서브타입** 은 **슈퍼타입** 의 부분집합으로 표현.

> 어떤 타입이 다른 타입의 **서브타입** 이 되기  위해서는 `100% 규칙` 과 `Is-a 규칙` 을 준수해야한다.

> \- Larman 2004

- 100% 규칙 : 슈퍼타입의 정의가 100% 서브타입에 적용돼야만 한다. 서브타입은 속성과 연관관계 면에서 슈퍼타입과 100% 일치해야 함.
- Is-a 규칙 : 서브타입의 모든 인스턴스는 슈퍼타입 집합에 포함돼야 한다. `subtype is a supertype` 을 만족해야 함.

##### 상속
한 타입이 다른 타입의 서브타입이 되기 위해서는 슈퍼타입에 순응<sup>conformance</sup> 해야 한다

순응에는 2가지 있는데,

######  구조적인 순응
- 타입의 내연과 관련된 100% 규칙을 의미.
- 서브타입은 슈퍼타이빙 가지고 있는 속성과 연관관계 면에서 100% 일치해야 함.

######  행위적인 순응
- 타입의 행위에 관한 것.
- 서브타입은 슈퍼타입을 행위적으로 대체 가능해야 함.
- 행위적인 순응을 흔히 **리스코프 치환 원칙**<sup>Liskov Substitution Principle, LSP</sup> 라고 함.

###### 상속의 또 다른 용도
코드 중복을 방지하고 공통 코드를 재사용하기 위한 언어적 메카니즘을 제공하는 것.

###### 서브타이핑과 서브클래싱의 용도

- 서브타이핑<sup>subtyping</sup> : 서브클래스가 슈퍼클래스를 대체할 수 있는 경우<sup>인터페이스 상속</sup>
- 서브클래싱<sup>subclassing</sup> : 서브클래스가 슈퍼클래스를 대체할 수 없는 경우<sup>구현 상속</sup>


###### 위임
상속 계층에서 수신된 메시지를 이해하는 기본적인 방법으로써, 현재 클래스에서 이해할 수 없다면 부모 클래스로 위임.


### 집합과 분해

##### 계층적인 복잡성
- 복잡성은 `계층` 의 형태를 띤다.<sup>시계의 모듈화 예</sup>
- 단순한 형태로부터 복잡한 형태로 진화하는 데 걸리는 시간은 그 사이에 존재하는 `안정적인 형태`의 수와 분포에 의존.

안정적인 형태의 부분으로부터 전체를 구축하는 행우를 **집합** 이라고 하고, 집합과 반대로 전체를 부분으로 분할하는 행위를 **분해** 라고 한다.

집합은 여러 형상을 하나의 단위로 다룸으로써 **복잡성** 을 줄인다. 불필요한 세부사항을 **추상화**함.

##### 합성관계
객체와 객체 사이의 **전체-부분** 관계를 구현하기 위해 **합성 관계** 를 사용.

> 부분을 전체 안혜 캡슐화함으로써 인지과부화를 방지.

```
주문 항목은 주문의 일부. 
```

단순한 물리적 통로만 존재하는 경우 **연관관계** 라고 함.
```
주문항목과 상품 간에는 연관된 관계만 존재.
```


###### 연관관계와 합성관계의 구분
포함하는 객체가 제거될 때, 포함된 객체도 함께 제거 되는 경우 **합성 관계**
그에 반대로 객체의 서로의 생명주기에 의존하지 않는 경우 **연관 관계**


##### 패키지
소프트웨어에서 구조를 단순화할 목적으로 서로 관련성이 높은 클래스 집합을 논리적인 단위로 통함.
**패키지** 혹은 **모듈** 이라고 함.

> 합성관계가 내부에 포함된 객체들의 존재를 감춤으로써 내부 구조를 추상화하는 것 처럼 패키지는 내부에 포함된 **클래스** 들을 **감춤** 으로써 시스템의 구조를 **추상화** 한다.