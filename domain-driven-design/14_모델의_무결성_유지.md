# 모델의 무결성 유지

대규모 시스템의 도메인 모델을 완전하게 단일화한다는 건ㅅ은 타당하지 않거나 비용대비 효과적이지 않다. 모델의 분화는 기술적 관심사 만큼이나 정치적인 분열과 다양한 경영상의 우선순위로 발생하기 마련. 완전한 통합을 가로막는 기술적 요인이 전혀 없더라도 프로젝트에는 다수의 모델이 나타난다.

그러나 이것을 그대로 두고만 볼 수 없다. 우리는 단일화 되기를 바라는 부분은 그대로 두고, 단일화 되지 않은 부분이 혼란을 초래하거나 다른부분을 손상시키지 않는지 확인해야 한다. 

> 우리에겐 다른 여러 모델간의 경계와 관계를 표시해줄 `수단`이 필요하다.

CONTEXT MAP이 프로젝트의 컨텍스트와 컨텍스트 간의 관계를 개괄적으로 보여주고, BOUNDED CONTEXT는 각 모델의 적용 가능성의 범위를 알려준다. 일단 컨텍스트가 제한되면 CONTINUOUS INTEGRATION 프로세스를 토대로 **모델의 단일화**를 유지할 수 있다.

## BOUNDED CONTEXT(제한된 컨텍스트)
서로 다른 모델을 다룰 경우, 컨텍스트에 적용하기 위한 판단이 명확하게 서지 않는 경우가 많다. 보통은 시스템이 예측불가능한 상태에 빠지고 나서야 모델에 차이가 발생했다는 사실을 깨닫는다. 만약 모순이 동일한 코드 기반에서 발생할 경우 이를 인식하기가 더욱 힘들다.

그러므로

모델이 적용되는 컨텍스트를 명시적으로 정의하라. `컨텍스트의 경계` 를 **팀조직**, **애플리케이션의 사용법**, **코드기반**이나 **데이터베이스 스키마** 같은 물리적인 형태의 관점에서 명시적으로 설정하라. 이 경계 내에서는 모델을 엄격하게 **일관된 상태**로 유지하고 경계 바깥의 이슈 때문에 초점이 흐려지거나 혼란스러워져서는 안된다.


> BOUNDED CONTEXT와 MODULE은 서로 동기가 다른 패턴이다. 
**두 객체 집합**이 각기 **다른 모델**을 구성한다면 두 객체 집합은 거의 항상 서로 다른 **개별 MODULE** 내에 위치한다.(물론 서로 다른 **네임스페이스**로 **경계**를 제공할 수 있다.) 그러나 MODULE은 단일 모델 내에 포함된 요소를 구성하는 데도 사용되며, 꼭 **개별 CONTEXT**만을 나타내는 것은 아님. BOUNDED CONTEXT 안에 MODULE이 만들어낸 개별 네임스페이스가 포함되면 모델의 단편화를 파악하기가 힘들긴 하다.

경계는 특별한 곳이므로 BOUNDED CONTEXT 와 BOUNDED CONTEXT 간의 관계를 보살핌과 주의가 필요하다. 

### BOUNDED CONTEXT 안의 균열 인식

1. 코드로 작성된 인터페이스가 서로 맞지 않는 경우.
2. 중복된 개념(실제로 같은 개념을 나타내느 두 개의 모델 요소)과 허위 동족 언어(같은 용어를 얘기하지만 실제로는 다른 개념)

위의 문제는 자동화된 테스트를 이용한 CONTINUOUS INTEGRATION 을 통해 문제점을 미리 파악할 수 있다.

## CONTINUOUS INTEGRATION

BOUNDED CONTEXT를 정의했다면 건전한 상태로 유지하자.

> 다수의 사람이 동일한 BOUNDED CONTEXT에서 작업할 경우 모델이 단편화 될 가능성이 높다. 팀의 규모가 커지면 문제가 증폭되지만, 서너 명의 소수인원도 심각한 문제를 야기할 수 있다. 그렇다고 시스템을 더 작은 CONTEXT로 분할한다면, 결국 가치 있는 수준의 통합과 응집성을 잃게 된다.

규모와 상관없이 **통합된 시스템**을 개발하는 데 필요한 수준의 **의사소통**을 **유지하기**는 **어렵다.** 기존 코드를 망가뜨릴지도 모른다는 두려움에 코드를 중복시키는 등의 소심한 행동을 방지해줄 안전망이 필요하다. XP에서 제시하는 각종 실천사항의 목표는 많은 사람들에 의해 지속적으로 수정되는 응집도 높은 설계를 유지하는 문제를 해결하는데 있다. 

> CONTINUOUS INTEGRATION 은 내부적으로 균열이 발생할 때 이를 빠르게 포착하고 정정할 수 잇을 정도로 컨텍스트 내의 모든 작업을 **빈번하게** **병합**해서 일관성을 유지하는 것을 말한다. 

가장 효과적인 프로세스

- 단계적이고 재생 가느한 병합/빌드 기법
- 자동화된 테스트 스위트
- 수정사항이 통합되지 않은 채로 존재하는 시간을 짧게 유지하는 규칙

> 단편화과 발생했다는 사실을 빠르게 알려줄 수 있는 자동화된 테스트와 함께 모든 코드와 그 밖의 구현 산출물을 빈번하게 병합하는 프로세스를 수립하라. 모델에 대한 시선의 차이를 극복하기 위해 **UBIQUITUOS LANGUAGE**를 사용하라.

## CONTEXT MAP(컨텍스트 맵)
문제 
1. 다른 팀에 속한 사람들은 CONTEXT 간의 경계를 인식하지 못한다.
2. 자신도 모르게 CONTEXT의 경계를 흐리게 하거나 연결되는 방식을 복잡하게 만든다.
3. 서로 다른 CONTEXT를 연결해야 하는 경우, CONTEXT를 서로에게 스며들게 한다.

BOUNDED CONTEXT간에 코드를 재사용하는 것은 위험.
CONTEXT MAP은 프로젝트 관리와 소프트웨어 설계 영역 사이에 걸쳐있는 개념.

> 프로젝트상의 유용한 모델을 식별하고 각 BOUNDED CONTEXT를 정의(비 객체지향 적인 하위 시스템에 대한 암시적인 모델도 포함)
> 의사소통을 위해 컨텍스트 간의 번역에 대한 윤곽을 명확하게 표현.
> 컨텍스트간에 공유해야 하는 정보는 강조함으로써 모델과 모델이 만나는 경계지점을 명확하게 하라.
> 각 컨텍스트의 영역을 나타내는 지도를 작성하라.(컨텍스트의 배치는 나중에 해도 된다!)


CONTEXT MAP은 형재 상황을 명확하게 표현하고 있다.(응집도 높게)

두 모델간의 번역을 수행하는 양방향 번역기
```note
Booking-Transport Network Translator

convertSpec(RouteSpecification spec) : List 
convertPath(List nodePath) : Itinerary
```

RoutingService의 유일한 연산
```java
public Itinerary route(RouteSpecification spec) {
	Booking_TransportNetwork_Translator translator = new Booking_TransportNetwork_Translator();

	List constraintLocations = translator.convertConstraint(spec);

	//NetworkTraversalService 에 접근
	List pathNodes = traversalService.findPath(constraintLocations);
	Itinerary result = translator.convert(pathNodes);
	return result;
}
```
그리 나쁘진 않다. 


### CONTEXT 경계에서의 테스트
다른 BOUNDED CONTEXT와 접촉 지점은 테스트 할때 특히 중요. 테스트는 귀중한 조기경보체계의 역할을 할 수 있으며, 특히 통제할 수 없는 모델의 세부사항에 의존할 때는 안심할 수 있게 해준다.

### CONTEXT MAP의 조직화와 문서화
팀의 모든 구성원이 서로 동일한 방식으로 개념적 경계를 이해하도록 활발히 의사소통해야 한다.
의사소통의 목적으로 예제와 같은 비공식적인 다이어그램도 좋다.

## SHARED KERNEL(공유 커널)
밀접하게 연관된 애플리케이션을 대상으로 작업중인 팀 간의 협력이 조율되지 않는다면 결과물을 조합하기 쉽지 않음. 
결국 처음부터 CONTINUOUS INTEGRATION을 적용했을 때 보다 더 많은 시간을 번역 계층을 개발하고 구조 개선하는데 허비하게 될 것이며, 동시에 UBIQUITOUS LANGUAGE를 구축하는 작업이 중복되고 UBIQUITOUS LANGUAGE로 얻을 수 있는 이점을 잃어버린다. 

> 두 팀간에 공유하기로 한 도메인 모델의 부분집합을 명시하라. 
> 기능 시스템을 더 자주 통합하라.(개별 팀에서 수행하는 CONTINUOUS INTEGRATION 빈도 보다는 적은 빈도로)
> 통합할 때는 양 팀에서 작성한 테스트를 모두 실행 할 것.





