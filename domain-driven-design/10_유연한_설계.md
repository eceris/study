# 유연한 설계

정교한 시스템을 만들 목적으로 이해하기도 쉽고 조립가능하게 만드려면 MODEL-DRIVEN DESIGN을 적당한 수준의 엄밀한 설계형식과 접목하고자 노력해야 한다. 단순한 모델을 새로 만들거나 사용하자면, 상대적으로 복잡한 설계가 필요할 수도 있다. 유연한 설계는 모델이 지닌 잠재력을 명백하게 표현하는 하부의 심층모델을 드러낸다.

레거시 코드를 유지보수하느라 허우적 댈 것인지, 복잡도의 한계를 뜷고 전진할 것인지의 차이를 결정하는 것은, 가장 **중요**하고 **난해**한 부분을 잘 다듬어 **유연한 설계**로 이끌어 내는 작업이다.

![유연한 설계](architecture-10-pattern.png)

## INTENTION-REVEALING INTERFACE(의도를 드러내는 인터페이스)

객체가 아름다운 이유는 까다로운 세부내용을 모두 **캡슐화**할 수 있고, 캡슐화된 코드는 단순하고 상위수준의 개념 관점에서 **이해**하기 쉽기 때문이다.

> 개발자가 컴포넌트를 사용하기 위해 컴포넌트 구현의 세부사항을 고려해야 한다면 캡슐화의 가치는 사라진다. 
> 추측하여 작성한 코드가 당장은 정상 동작했다고 하더라도 설계의 개념적 기반은 무너지고 개발자들은 서로 의도가 거긋난 상태로 일하게 된다.
> **클래스와 메소드의 이름**은 개발자간의 의사소통을 개선하고 시스템추상화를 향상시킬 아주 좋은 **기회**이다.

설계에 포함된 모든 공개된 요소가 조화를 이루어 인터페이스를 구성하고, 각 요소의 이름을 토대로 설계의도를 드러낼 수 있는 기회를 얻게된다.(타입이름, 메소드이름, 인자 이름이 모두 결합되어 **INTENTION-REVEALING INTERFACE** 가 된다.)

예 : 페인트 혼합 애플리케이션

## SIDE-EFFECT-FREE FUNCTION(부수효과가 없는 함수)
연산은 크게 명령과 질의라는 두가지 범주로 나눌수 있다. 
- 질의 : 변수 안에 저장된 데이터에 접근하거나, 저장된 데이터를 기반으로 계산을 수행해서 시스템으로부터 정보를 얻는 연산.
- 명령 : 변수의 값을 변경하는 등의 작업을 통해 시스템의 상태를 변경하는 연산.

> 부수효과 : 의도하지 않은 영향력을 발생시키는 효과.
> 함수 : 부수효과를 일으키지 않으면서 결과를 반환하는 연산.


명령(상태를 변경하는 관찰가능한 메소드)을 도메인 정보를 반환하지 않는 아주 **단순한 연산**으로 엄격하게 분리하라. 한걸음 더 나아가 책임에 적합한 어떤 개념이 나타난다면 **복잡한 로직**을 **VALUE OBJECT**로 옮겨서 부수효과를 통제하라.

## ASSERTION(단언)
ASSERTION을 사용하면 ENTITY의 부수효과가 명확해지고 다루기 쉬워진다.

> 연산의 부수효과가 단지 **구현**에 의해서만 함축적으로 정의될 때 다수의 위임을 포함하는 설계는 **인과관계**로 혼란스러워진다. 이렇게 되면 **캡슐화**의 가치가 사라지고, 구체적인 경로를 **추적**해야한다는 필요성으로 추상화가 무의미해진다. 

자동화된 단위 테스트를 작성하면 언어 차원에서의 지원 부족을 보완할 수 있다. **ASSERTION**은 절차가 아니라 상태에 대해서만 기술하므로 **테스트**로 작성하기가 쉽다.
인자를 변경하는 것은 매우 위험한 종류의 부수효과에 해당한다.

## CONCEPTUAL CONTOUR(개념적 윤곽)
요리책에 들어있는 **판에 박힌 규칙**은 효과적이지 않다. 도메인에는 잠재적인 일관성이 존재하므로 도메인의 일부 영역에서 적절한 모델을 발견하면 나중에 발견되는 다른 영역과도 **일관성**을 유지할 가능성이 높다. 새로 알게된 개념이나 요구사항을 코드에 적용하다 보면 **CONCEPTUAL CONTOUR** 가 나타난다.

> 결정을 내릴 때마다 자문해보자. "이 개념이 현재 모델과 코드에 포함된 관계를 기준으로 했을때, 적절한 것인가? 혹은 현재 기반을 이루는 도메인과 유사한 윤곽을 나타내는가??"
> 지속적인 리팩토링을 토대로 변경되는 부분과 변경되지 않는 부분을 나누는 중심 축을 식별하고, 변경을 분리하기 위한 패턴을 명확하게 표현하는 **CONCEPTUAL CONTOUR** 를 찾아라.

## STANDALONE CLASS(독립형 클래스)
의존성이 하나만 있더라도 동시에 두 개의 클래스를 고려해야하고, 그 관계의 본질을 생각해야 한다. MODULE과 AGGREGATE 모두 지나치게 얽히고 설키는 상호 의존성을 방지하는 것이 목적인데, 만약 그렇게 된다면, 개발자에게 정신적 과부하를 준다.

> 낮은 결합도는 객체 설계의 기본 원리다. 가능한 결합도를 낮추고자 노력하고 현재 상황과 **무관한** 모든 개념을 **제거**하라. 독립적인 클래스는 MODULE을 이해하는데 따르는 부담을 덜어준다. 
> 모든 의존성을 제거하는 것이 아니라 모든 비본질적인 의존성을 제거하는 것이 목적.

## CLOSURE OF OPERTAION(연산의 닫힘)
적절한 위치에 **반환 타입**과 **인자 타입**이 동일한 연산을 정의 하라. 닫힌연산은 부차적인 개념을 사용하지 않고도 고수준의 인터페이스를 제공한다.
이러한 패턴은 소프트웨어를 분명하고, 예측 가능하며, 전달력 있게 만든다면 추상화와 캡슐화의 목표를 효과적으로 달성할 수 있다.




