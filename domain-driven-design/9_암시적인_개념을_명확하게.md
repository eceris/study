# 암시적인 개념을 명확하게
심층모델이 강력한 이유는 심층 모델에 사용자의 행위, 문제, 문제의 해법에 대한 본질적인 지식을 간결하고 유연하게 표현하는 중심 개념과 추상화가 담겨있기 때문이다. 

## 개념 파헤치기
개발자는 잠재해 있는 암시적인 개념을 드러내는 단서에 민감해야 하며, 이따금 한발 앞서 미리 암시적인 개념을 찾아야할 때도 있다. 

### 언어에 귀를 기울여라
도메인 전문가가 사용하는 언어에 귀 기울여라. 
만약 사용자나 도메인 전문가가 설계상의 어디에도 표현되지 않은 어휘를 사용하고 있다면 그것은 곧 경고 신호다. (기회라고도 표현하는데, 누락된 표현을 설계에 포함시켜 모델과 설계를 성숙시키는 기회가 될 수도 있다.)

### 어색한 부분을 조사하라. 
필요한 개념이 늘 대화나 문서로 인식할 수 있을 만큼 확연히 드러나 있지는 않다. 게다가 작업은 원할하게 수행하지만 할당된 이룹 책임이 어색하다는 것을 발견할지도 모른다. (보통은 도메인 전문가가 발견하지만 필요한 경우에는 개발자가 직접 문제 도메인을 파헤쳐야만 한다.)

### 모순점에 대해 깊이 고민하라

### 서적을 참고하라
책을 읽는다고 해서 그래도 이용할 수 있는 해법을 얻는 건 아니다. 다만, 해당 분야를 두루 경험한 사람의 정제된 경험을 비롯해 개발자가 직접 시도해볼 만한 출발점 정도는 제시할 것이다. 덕분에 개발자는 바퀴를 다시 발명하는 수고를 아낄 수 있다. 

### 시도하고 또 시도하라
모든 방향 선회가 단지 갈팡질팡하는 것에 불과한 것은 아니다. 이는 모델에 좀더 심층적인 통찰력을 반영했음을 의미한다. 

## 다소 불명확한 개념을 모델링 하는 법

### 명시적인 제약 조건
제약조건은 특별히 중요한 범주의 모델 개념을 형성한다. 흔히 제약조건은 암시적인 상태로 존재하며, 이를 명시적으로 표현하면 설계를 대폭 개선할 수 있다. 

> 규칙이 더 복잡해지면 어느 암시적인 개념과마찬가지로 규칙을 적용해야 하는 객체와 연산을 압도하기 시작한다.
> 규칙의 복잡도에 비례해 제약조건을 표현하는 메소드가 비대해지더라도 호출 메소드는 단순한 상태를 유지하고 본연의 작업에만 집중할 수 있다.

제약 조건을 포함한 객체의 설계가 어딘가 잘못되어 있음을 나타내는 냄새

1. 제약 조건을 평가하려면 해당 객체의 정의에 적합하지 않은 데이터가 필요한 경우
2. 관련된 규칙이 여러 객체에 걸쳐 나타나며, 동일한 계층 구조에 속하지 않은 객체 간의 중복 또는 상속관계를 강요하는 경우
3. 설계와 요구사항에 관한 다양한 논의는 제약조건에 초점을 맞춰 이뤄지지만, 정작 구현단계에서 절차적인 코드에 묻혀 명시적으로 표현되지 않는 경우

> **제약조건**이 객체가 담당하는 기본 책임을 모호하게 만들거나 제약조건이 도메인과 관련된 대화에서는 중요한 개념으로 다뤄지지만 **모델 내**에 **명확하게 표현되어 있지 않다면** 제약조건을 명시적인 **객체**로 **분리**하거나, 나아가 일련의 객체와 관계의 **집합**으로 모델링할 수 있다.

### 도메인 객체로서의 프로세스
Service는 프로세스를 명시적으로 표현하는 한 가지 방법이기는 하지만, 여전히 너무나도 복잡한 알고리즘을 캡슐화한다. 이런 경우 프로세스를 수행하는 방법이 한 가지 이상일 때 취할 수 있는 또 다른 접근법은 **알고리즘** 자체 또는 그것의 일부를 **하나의 객체**로 만드는 것이다.

> **SPECIFICATION**은 특정한 종류의 규칙을 표현하는 매우 **간결한 수단**을 제공하며, 조건 로직으로부터 규칙을 분리해서 규칙이 모델 내에서 분명해지게끔 만들어준다.

## SPECIFICATION(명세)
SPECIFICATION은 다른 객체에 대한 제약조건을 기술하며, 제약 조건은 존재할 수도 있고 존재하지 않을 수도 있다. 특별한 목적을 위해 술어<sup>predicate</sup>와 유사한 명시적인 VALUE OBJECT를 만들어라. SPEFICIFICATION은 어떤 객체가 특정기준을 만족하는지 판단하는 술어<sup>predicate</sup>다.

### SPECIFICATION의 적용과 구현
SPECIFICATION의 주된 가치는 매우 상이해보이는 애플리케이션의 기능을 하나로 **통합**해준다. 

1. 객체가 어떤 요건을 충족시키거나 특정 목적으로 사용할 수 있는지 가늠하고자 객체를 **검증**
2. 컬렉션 내의 객체를 **선택 혹은 질의**
3. 특정한 요구사항을 만족하는 새로운 **객체의 생성**을 명시

SPECIFICATION의 가장 단순한 용도는 **검증**이다. 또한 객체의 생성을 SPECIFICATION을 사용하지 않을 경우, generator를 작성할 수 있다. 하지만 이러한 구현은 인터페이스로부터 분리할 수 없다. SPECIFICATION을 사용할 경우 **객체의 생성**과 동시에 결과물을 **검증**하기도 하는 명시적인 방법이 모델에 포함되어 테스트하기가 수월하다.